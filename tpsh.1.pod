=pod

=head1 NAME

tpsh -- Terry's Portable SHell

=head1 SYNOPSIS

tpsh [-abCEefIimPpsuVvx] [-c string] [arg ...]

=head1 DESCRIPTION

=head2 Overview

=head2 Invocation

How tpsh behaves is dependent on how it was started, or "invoked" by the user.
When first starting up, tpsh will process its command line arguments for
options as explained below under L</Argument List Processing>. Any non option
arguments remaining in the on the command line after this processing has been
completed, specify a script and parameters.

If tpsh is executing a shell script through a command line argument, it is
assumed to be a I<non-interactive> shell; otherwise if tpsh's standard input
is connected to a terminal or the B<-i> option was given: tpsh assumes it is
to behave as an I<interactive> shell should. A non-interactive shell reads
commands from the named file or standard input until receiving the end of
file marker.  An interactive shell initializes your systems L<Term::ReadLine>
module and displays a command prompt. Commands are read from standard input
until the shell is exited or end of file is received.

tpsh will always inspect the initial environment, and modify it accordingly
(see L</ENVIORNMENT>). tpsh then attempts to change to the users personal
directory, if running as an interactive shell; scripts are run from the current
working directory. Interactive sessions then inspects the ENV environment
variable for shell initialization files before issuing the prompt.
 

=head2 Argument List Processing

Since most of these options may be set either at invocation or at run time:
both the short and long names have been listed here for each option. The short
form may only be specified as a command line argument to tpsh. The long form
may be passed to the built-in set command using the -o/+o option to the set
command (described later in L</Built-in Commands>.)

=over 8

=item B<-a> allexport

Automatically export variables to the environment; i.e. C<FOO=BAR> has the same
effect as C<FOO=BAR; export FOO>.

XXX not implemented yet

=item B<-A> autohistory

Causes tpsh to load saved history from HISTFILE after processing the users ENV, and to save the shells history to HISTFILE before terminating.

XXX not implemented yet

=item B<-b> notify

Enable asynchronous notification of background job completion.

XXX not implemented yet

=item B<-C> noclobber

Do not overwrite existing files with I/O redirection; e.g. C<< cat f1 f2 > f1 >>
becomes an error under noclobber.

=item B<-c string> 

Commands are read from the following argument (string) instead of from standard
input. Keep in mind that multi-word strings must be quoted in most shells.

=item B<-D> debug

Enables debugging output. Intended for development and internal testing purposes only.

=item B<-E> emacs

Use key bindings for interactive line editing that resemble the L<emacs(1)>
operating system. (This option counteracts -V)

XXX not implemented yet

=item B<-e> errexit

Exit the script immediately if any untested command fails. A command is
considered tested if it appears within a conditional statement or on the left
hand side of any logical operator, such as the C<&&> or C<||> operators.
Because user defined functions and aliases are mealy a form of textual macro,
the contents of any function is B<not> exempt from testing a commands exit
status..

XXX not implemented yet

=item B<-f> noglob

Disable filename globing; e.g. C<vi f*> passes the C<f*> to vi, rather then all
files matching the pattern.

=item B<-I> ignoreeof

Ignore end of file indicators from input when running in interactive mode. 

=item B<-i> interactive

Force th shell to execute in interactive mode.

=item B<-m> monitor

Enables built-in commands used for job control; e.g. fg, bg, jobs, etc.

=item B<-n> noexec

if not interactive, read commands but do not execute them. Normally this is
used for checking a script for syntax errors without running it.

=item pathext

When executing commands, perform file extension checks before giving up.

=item reportpipe

Print an additional error message whenever SIGPIPE is received; default off.

XXX not implemented yet

=item B<-s> stdin

Read the commands from standard input (set automatically if there are no
command  line arguments left after option parsing).

=item B<-V> vi

Use key bindings for interactive line editing that resemble the L<vi(1)> text
editor. (This option counteracts -E)

XXX not implemented yet

=item B<-v> verbose

Before executing a command, write it to standard out; you may prefer the C<-x>
option for most situations.

=item B<-x> xtrace

Before executing a command, write it to standard error prefixed by the PS4
environment variable. More useful then the C<-v> option.


=back

=head2 Lexical Structure

=head2 Quoting Rules

=over 8

=item Single Quotes

Enclosing characters within single quotes serve to remove any special meaning
they may have. Inside single quotes, no parameter or macro expansion is
performed, whitespace will be maintained where applicable, and no escape
characters are interpreted. The literal characters are retained, making it
impossible to nest single quotes.

=item Double Quotes

Enclosing characters within double quotes restricts the evaluation to parameter
expansion and backslash escapes. The backslash inside double quotes is
historically weird: and the shell may not quite understand them correctly.

=item Backquotes (or backticks)

The back-quotes, or `back-ticks` as this documentation prefers serve as a
means for executing a command expression, and substituting the expressions
output in place of the quotes. The use of back-ticks behaves exactly like the
B<$()> command substitution syntax, but without three presses of the shift
key. No special evaluations are performed on the contents of back-quotes, only
simple text substitution.

	$ echo `ls | head -n 1`

is equivalent to

	$ echo `sh -c "ls | head -n 1"`

and both expand to 'echo first line of ls output'.

XXX this should be changed to use tpsh instead of perls default.

=back

=head2 Commands

tpsh interprets the words it reads as commands for execution through a queue.
Complex commands are broken down into simple commands and enqueued. The first
word of each simple command is checked for expansion in accordance with the
shells quoting rules, and then executed by the shell. To illustrate a point, if
the following simple command was given to tpsh:

	$ vi -c "set ai" file.c

the argument vector (argv) of vi will be as follows:

	argv[0] = '/path/to/vi'
	argv[1] = '-c'
	argv[2] = 'set ai'
	argv[3] = 'file.c'

If no quotes were used around set ai, then they would have been interpreted as
separate arguments (2 and 3), pushing file.c further down the list (4).

=head3 Simple Commands

When processing the command queue, the shell performs the following actions
for each simple command:

=head3 Complex Commands

Complex commands are groupings of simple commands, keywords, and various
operators that tie together a more challenging command. Complex commands may
be:

	simple commands

	pipelines

	lists

	compound commands

	anonymous macros

Unless otherwise stated, the exit status of a complex command is always that
of the last simple command executed by the command.

XXX not implemented yet.

=head3 Control Flow Keywords

=over 8

=item B<if> I<list> B<then> I<list> [B<elif> I<list> B<then> I<list>] ... [B<else> I<list>] B<fi>

The I<list> immediately following the B<if> keyword is executed, if it returns
an exit status of zero, then the list following B<then> is executed. If the
I<list> immediately following the B<if> returns non-zero, then any supplied
B<elif> groups will be executed likewise, until one succeeds. If given, and no
preceding B<if> or B<elif> resulted in an exit status of zero: the I<list>
following B<else> is finally executed.

=item B<while> I<list> B<do> I<list> ... B<done>

The I<list> immediately following the B<while> keyword is executed, if it
returns an exit status of zero, then the list following B<do> is executed until
the B<while> evaluates to a non-zero exit status.

=item B<until> I<list> B<do> I<list> ... B<done>

Exactly like the while control flow, except the exit status is inverted.

=item B<break>, B<last>

Exits the currently running while, until, or for loop.

=item B<continue>, B<next>

Proceeds to the next iteration of the current while, until, or for loop IAW
evaluating the loop condition.

=back

=head3 Command Search & Execution

The shell understands several types of commands: built-in commands, macros,
and external programs. The command is searched for by name in a predefined
order, and then executed.

First a command is checked if it is a named macro. tpsh's use of named macros
is analogous to other shells use of B<alias>es or shell B<function>s. The
macro will be expanded recursively before execution occurs, the expansion
replaces the macro name in the queue. Refer to L</Macro Expansions> below for
the gory details of how macros are expanded.

Next tpsh examines if the command is built-in to the shell. If so, the command
is executed internally without spawning a new process. tpsh provides many
built-in commands either for convenience or portability; they are documented
under L</Built-in Commands>.

Lastly if the command does not match a named macro or built-in command, it is
assumed to be an external program to be executed. If the command begins with
an absolute or relative file specification (i.e. a pathname), it will be
executed directly. Other wise the name is subject to a PATH Search, and
expanded to a suitable file specification for invocation by L<exec>.

If the command could not be executed, an error message will be printed to the
shells standard error stream, and exit status set accordingly.

=head4 Path Search

Internally tpsh maintains a hash table of all known commands, by mapping these
command names to their full path names it is possible to speed up the
execution of commands by minimizing the search procedure to a simple command
=> filename look up. The shell is made aware of external commands by setting
the PATH environment variable, and B<rehash>ing the saved values for
performance. It is also possible to automate a limited understanding of file
extensions though the use of the PATHEXT variable and pathext shell option.

Terry's Portable SHell performs the following actions whenever it must search
the users PATH for a program:

=over 8

=item 1. 

If the command name looks like a file specification, it is executed without
further comment.

=item 2.

The shell consults an internal hash table with the command name. If it is
found, the saved file specification is executed.

=item 3.

If the command still has not been found: the users PATH environment variable
is interpreted as a list of directories separated by the HASHSEP environment
variable. Each directory is manually searched for the command; if the pathext
option or PATHEXT variable is not set, then the search path ends here.

=item 4.

If the user has set the PATHEXT environment variable, and the shells pathext
option is also set: repeat step 2 with each element of PATHEXT until the
command has been found or continue to step 5.

=item 5.

If step 4 failed, repeat step 3 in the same manor, or give up.

=back

=head4 Path Extensions

In order to reduce typing, and make certain antique operating systems easier
to use: tpsh allows the user to specify command suffixes or "Path extensions"
to try befor egiving up. The PATHEXT environment variable if set, will be used
to generate a list of possible filename extensions. By default tpsh enables
the pathext option, but does not set a value for PATHEXT.  If the pathext
option has been disabled, no checks are made.

The command suffixes in PATHEXT are interpreted similar to PATH variable. Each
element of the list is appended to the commands name, such that if 

	PATHEXT='.sh:.py:.rb'

Then 'name' will be checked as 'name', 'name.sh', 'name.py', and 'name.rb'
before giving up the search.

No attempt is made at understanding file or MIME type associations: your
operating system must understand how to execute the named file. Microsoft
systems should have file associations setup to run the appropriate program,
most Unix systems will obey the usual C<magic number> exec pattern.

=head2 I/O Redirections

It is possible to change where a command reads its input or sends its output,
by using an I/O redirection; for the uninitiated I/O stands for Input and
Output. The most common usage of an I/O redirection is to save a programs
output to a file, or make it read its input from a file; however much more is
possible.

Redirections operators use the format of: C<operator file>. The I/O
redirection operators follow the general style of an arrow representing the
direction in which to redirect the file descriptor, and an arrow and ampersand
representing the file descriptor to close or duplicate. A list of all these
operators follows:

XXX only <, >, and >> on their standard file descriptors are currently
implemented

=over 8

=item [I<n>]> F<file>

Redirect stdout (or file descriptor I<n>) to F<file>.

=item [I<n>]>| F<file>

Same as the above C<< > >> operator, but override the B<noclobber> option.

=item [I<n>]> F<file>

Append stdout (or file descriptor I<n>) to F<file>.

=item [I<n>]< F<file>

Redirect stdin (or file descriptor I<n>) from F<file>.

=item [I<n1>]<&I<n2>

Duplicate stdin (or file descriptor I<n1>) from file to descriptor I<n2>.

=item [I<n>]<&-

Close stdin (or file descriptor I<n>).

=item [I<n1>]>&I<n2>

Duplicate stdout (or file descriptor I<n1> to file descriptor I<n2>.

=item [I<n>]&-

Close stdout (or file descriptor I<n>).

=back

Note that stdin, stdout, and stderr are common terms for standard input,
output, and error; respectively. You can specify stdin, stdout, or stderr as
file descriptors 0, 1, or 2; also respectively.

=head2 Pipelines

=head2 Command Macros

Several features of other shells are considered by tpsh, to be a form of
command "Macro" for logical reasons (read: Terry's brain works this way). There
are 4 kinds of command macro, aliases, functions, and groups.

XXX positional parameters are NOT implemented yet!

=head3 Anonymous Macros

An anonymous macro may be defined with the following syntax:

	{ commands }

Note that anonymous macros have access to the shells positional parameters,
unlike named macros which instead have localized positional parameters. The
content within the curly braces may contain anything that a named macro may /*
except things like local varname */

=head3 Named Macros

There are several ways to record a command macro for later use, a declaratory
syntax and an imperative syntax: often referred to as aliases and user defined
functions respectively.

=head4 Aliases

Command aliases provide a simple form of macro expansion at run time. An alias
is is defined with either of the following syntaxes:

	alias la='ls -a'
	alias ll 'ls -l'

The former is the Bourne syntax, while the latter is the CSH syntax. Simple
text substitution will replace 'la' with 'ls -a' and 'll' with 'ls -l' during
evaluation. An alias is functionally equivalent to the following statement:

	la() {
		ls -a
	}

Therefore any attempts to access the shells positional parameters ($1, $2, $*,
etc) from within an alias definition will instead access the positional
parameters of the macro. This allows one to define an alias such as:

	alias qux='qux -f $1 -ab $2'

and may be called like so:

	qux foo bar

with the following expansion:

	qux -f foo -ab bar

Note that the single quotes around the alias definition is important; single
quotes prevents tpsh from expanding the positional parameters B<before> storing
the alias. The right hand side of an alias definition is not treated specially,
and therefore obeys the shells usual quoting schematics.

=head4 User Defined Functions

A named macro may also be defined as if it were a function:

=over 8

=item Bourne Again syntax

	[function] name() command

The definition of C<command> may be any simple command or anonymous macro body.

=item Terry's syntax

	macro name( commands )

=back

The macro then can be executed by invoking C<name> as if it were a simple
command. The primary distinction between aliases and user defined functions,
is only a matter of syntax: they are B<functionally> equivalent macros.


Arguments are passed to a user defined function (named macro) by localizing the
shells positional parameters to the currently executing macro; thus in the
above example the C<$0> parameter would expand to C<name> rather then C<tpsh>.
When using the Bourne style of defining a function, often the C<command>
portion is a list of commands grouped within curly braces: in tpsh this context
is what gives macro its name, therefore it is no longer anonymous and receives
localized positional parameters in order to simulate C<function arguments>.


=head3 Example Macros

	alias lf=ls -f
	alias pgr less
	macro cvs-st(cvs status | grep -i Status:)
	function new-script() {
		echo '#!/usr/bin/env' " $1\n\n" >> $2
	}

=head2 Built-in Commands

=over 8

=item B<alias> [I<name>=I<string> | I<name string>]

Creates a named macro or C<alias> with name and definition I<string>. Both the
Bourne and C-Shell syntaxes are emulated (respectively). When using the first
form, the string value should be quoted to ensure the that macro expansion
occurs at the desired time (i.e. run time or allocation). For one line
expressions, you may find the C-Shell syntax or tpsh's B<macro> built-in more
convenient; for more complex expressions the B<function> built-in is better
suited to created a named macro then the B<alias> built-in. If I<name> is
specified without any definition, then the definition of macro I<name> will be
displayed if it exists; without any arguments, the B<alias> command displays
all named macros in a format then can easily be processed by L<awk(1)>.

=item B<builtin> I<command> [I<arg ...>]

Execute built-in command I<command> with specified arguments. If you have
overridden a built-in command using a macro, you can still use the built-in by
invoking it through the B<builtin> built-in command, are you tongue twisted
yet?

=item B<cd> [I<directory>]

Change the shells current working directory to the specified directory, or to
the users HOME directory if no directory was specified. When the CDPATH
environment variable is set, and I<directory> does not begin with /, ., or ..,
then the directories listed in CDPATH will be searched for the specified
directory.  If CDPATH is unset, then only the current directory is searched.
The format of CDPATH is explained in L</ENVIRONMENT>.

=item B<exec> I<command> [I<args ...>]

The shell will replace itself with the specified I<command> using the L<exec>
function. I<Command> can not be a shell built-in or macro.

=item B<chdir> [I<directory>]

A synonym for the B<cd> built-in command.

=item B<cls>

Attempt to clear the terminal screen. If your perl distrubtion supports the
L<Term::Cap> module correctly, the usual unix convention is used; other wise
enough whitespace will be generated for the average display.

=item B<exit> [I<status>]

Exit the shell with exit status I<status>, if status is omitted then the exit
status of the last command is used. Note that I<status> should be an integer.

=item B<fc> [B<-e> I<editor>] [B<-rln>] [I<first>] [I<last>]

Fudged Command. Select the most recently executed commands within the range
(inclusive) of I<first> and I<last>. The commands are placed into an editor for
fudging and executed similar to a shell script. The default is to use the
FCEDIT environment variable as the editor, and to fall back on the EDITOR
variable when that is not set. If the B<-e> option was specified, then commands
will instead be edited using I<editor>. If the B<-r> option is specified, the
order of commands is reversed.  When the B<-l> option is given, list but do not
execute the commands. The B<-n> option may be used to in conjunction with B<-l>
to disable the display of line numbers; when editing commands, line numbers are
never displayed.

The history index range, I<first> and I<last> may be either integers or
strings. If it is numeric it is treathed as an index into the history list.
Relative offsets are semi-possible.  If the index is prefixed with a '-', e.g.
C<fc -l -- -5>, then the index is interpreted as negative indexe that counts
backwards from the last command in the history list, thus -1 refers to the
previous command and +1 to the first command. When string indexes are used, the
shell searches history from the oldest command until it finds a line matching
against I<first>, and then corrispondly finds the last match for I<last>.

=item B<false>

Always returns a non-zero exit status.

=item B<function> I<name()> [I<list ...>]

Defines a named macro using syntax that resembles the GNU Bourne Again SHell.
I<List> may be any simple or grouped command. Defining a complex or multi-line
function is best done by binding I<name()> to an anonymous macro; which is done
by using {} or () grouping. For short (i.e. one line) macros, you may find the
B<macro> built-in to be a more concise notation. See L</Command Macros>.

=item B<hash> [B<-r>] [I<command ...>]

Displays the shells internal hash table of C<command=/path/to/command>, which
is used for caching the value of the PATH environment variable. Any arguments
given to the B<hash> built-in command, are assumed to be the name of a program
found in the users PATH, which is to be removed from the shells hash table. If
the B<-r> option is specified, then delete the entire contents of the hash
table.  Note well that this does I<not> allow you to remove a single command
from your search PATH, it only manipulates internal data structures used to
speed up command execution. 

=item B<history> [I<edit> | I<help> | I<list> | I<load> | I<save> ] [I<args>]

Front end for the B<fc>, B<loadhist>, and B<savehist> commands. C<history edit>
is a synonym for C<fc>, C<history help> displays a usage message, C<history
list> is a synonym for C<fc -l>, C<history load> is a synonym for C<loadhist>,
and C<history save> is a synonym for C<savehist>. I<args> will be passed on to
the underlaying command, e.g. C<history list 3 4> is the same as C<fc -l 3 4>.
If called without arguments, it will behave as if called like C<history list>.
Note that C<history [args]> is I<not> a synonym for C<history list [args]>.

=item B<loadhist> [I<file> ...]

Load saved history from the indicated I<file>s and append it to the shells
current history. Note that depending on the capabilities of the
L<Term::ReadLine> module that has been loaded (TPSH_READLINE), you may only be
able to access loaded history through built-in commands like B<fc>. This is not
tpsh's fault. If no I<file> is specified, B<loadhist> inspects the current
value of HISTFILE before giving up.

=item B<macro> I<name(> [<command ...>] I<)>

Defines a named macro using a tpsh specific syntax. There must be a space after
the opening parentheses, and if I<command> is given there must also be a space
before the closing parentheses. An empty macro may be defined as C<macro
name()>, but not C<macro name()>. I<Command> may be any arbitrary command line
(similar to what the B<eval> built-in command accepts), and will be stored as a
named macro with I<name>. See L</Command Macros>.

=item B<pwd> [B<-L> | B<-P>]

A built in function for printing the current working directory. If the B<-P>
option is specified, print the current working directories real path; if the
B<-L> option is specified, print the shells idea of its current working
directory.  The B<-L> option is the default behaviour.

=item B<read> [B<-p> I<prompt>] [B<-t> I<timeout>] I<variable ...>]

Read a line from standard input, split by fields, and assign each field to the
indicated I<variable>s. If the number of variables is less then the number of
fields, the remaining fields will be stored 'as is' in the last variable. If
there are more variables then fields, the excess variables will be defined with
empty strings. A prompt may be printed before reading input, by using the B<-p>
option. The B<-t> option may be used to specify a timeout in which to abort the
operation, should the user take their sweet time about pressing CR. The
I<timeout> value can take an optional C<s>, C<m>, or C<h> suffix to denote
seconds, minutes, or hours. If no suffix is given, C<s> will be assumed.

=item B<savehist> [I<file>]

Save the current shells history to indicated I<file>, or HISTFILE if no I<file>
was specified. The history file will be modified, appending the shells current
history based on the value of HISTSIZE.

=item B<set> [B<-/+abCEefIimVvx>] [B<-/+o> I<longname>] [B<-c> I<string>] [B<--> I<arg ...>]

If no options are given, the B<set> command displays the values of all shell
variables.

If options are given using either short form or the C<-/+o longname> form; it
sets or clears the specified options as described in the above section
L</Argument List Processing>. Introducing an option with a dash (C<->) enables
the option, while using a plus (C<+>) disables the option.  A C<--> or plain
C<-> will stop option processing and will force the remaining words on the
command line to be treated as arguments.

When called like C<set -o>, the values of options are pretty printed in long
format.

If the B<--> option is specified or only bare words are given, set will replace
the shells positional parameters with whatever arguments follow. If no
arguments follow the B<--> option, all the positional parameters will be
cleared, as if the user had executed C<shift $#>.

=item B<sleep> I<timespec>

Causes tpsh to pause execution for I<timespec> using the L<sleep> system call.
The I<timespec> is assumed to be an integer number of seconds to sleep. An
optional suffix of C<s>, C<m>, or C<h> can be used to denote seconds, minutes,
or hours.

=item B<true>

Always returns exit status of 0.

=item B<type> [I<name ...>]

Interpret each I<name> as a command, then print the result. Possible types are:
built-in command, command, macro, or not found. For convenience, if an
executable is found in the current directory tpsh will print C<command may be
$PWD/command> before giving up. For macros, the stored definition is printed;
for command, the complete pathname is printed; for built-in command, tsph will print command is a shell builtin.

=item B<which> [B<-as>] [B<--all> | B<--silent>] I<command ...>

Check for the presence of I<command> by searching the users PATH environment
variable. The result of the search is then printed to standard output, subject
to the options given by the user. I<Command> may be a built-in command, macro,
or the name of a program without a path (e.g. C<ls>). If the B<-s> option is
specified, return 0 if all commands were found, and 1 otherwise; but do not
generate I<any> output. If the B<-a> option is specified, continue searching
after command has been found, printing all occurrences to standard output. Nota
Bene: for compatibility with other traditional implementations shells, B<which>
does not interpreted the users PATHEXT variable or the shells pathext option;
use B<type> instead.
 
=back

=head2 File Globbing

Unless the B<noglob> option is set, tpsh will attempt to evaluate several
special characters within pathnames, substituting their expansions for the
original patterns: this is commonly known as file[name] globing. You can think
of globing as the fusion of filename completion with a subset of regular
expression syntax.

tpsh understands the following glob characters:

=over 8

=item \

Quote the next glob character. C<\*> becomes a literal C<*> character, rather
then the expansion of the C<*> glob character.

=item []

Group one or more characters into a class; glob characters within the class
must be quoted. C<x[abc]> matches C<xa>, C<xb>, or C<xc> but never C<xab>,
C<xac>, etc. (for matching that, see below). To specify a range of characters,
use a dash: C<[a-zA-Z0-9]>. Nota bene: a-Z is an error. In order to negate or
'complement' a character class, prefix it with an exclamation point:
C<[!a-z]>.

=item {}

Multiple pattern match. Expressions within the curly braces are treated like
an alternating sub pattern: C<f.{zip,tar}> is short hand for C<f.zip f.tar>.
An empty '{}' is not interpreted as a glob.

=item *

Match any string of characters: C<foo*bar> matches any filename beginning with
foo and ending with bar.

=item ?

Match any single character: C<foob?r> will match C<foobar> or C<foober> but
not C<fookbar> or C<foobeer>.

=item ~

User name and home directory expansion. The 'tilde' symbol on it's own will
expand to the path to the current users personal directory (HOME). If suffixed
with a user name, it instead expands to that users personal directory.

=back

The glob characters can be combined together to form a more complex 'glob
pattern', which may be equally more useful. If no expansion is possible, tpsh
will abort the command and report an error.

tpsh's default globing behaviour should be suitable for most situations,
however if it is not you may customize it through POSIX flags. tpsh will check
the environment for a variable named TPSH_GLOB_FLAGS, and pass it on to the
underlaying L<File::Glob> module.

=head1 ENVIRONMENT

Environment variables may be broken down into variables that I<should> be
inherited from the invocation environment, variables set by tpsh on startup,
and variables that are not automatically set; but never the less have
significance to tpsh's behaviour. Most variables will retain their original
value if found in tpsh's invocation environment.

An environment variable is set if it contains an string or numeric value.
Variables may be unset by setting them to the empty string, or by using the
B<unset> built-in command.  

=head2 From Invocation Environment

These variables should be inherited by tpsh at startup, if not they will be
initialized to sane values as noted below. 

=over 8

=item USER, LOGNAME, USERNAME

The name of the currently logged in user. One of these variables must be set by
the operating system before the shell is executed, then tpsh will set the other
variables to match unless they already exist. If I<none> of these variables have
been set by the invocation environment, tpsh will pop a cork.

=item HOME, HOMEPATH, USERPROFILE

The path to the users personal or C<home> directory, and tpsh's default
starting directory. tpsh will attempt to set these variables to the correct
values if necessary.

=item PATH

The search path used for finding executables. PATH is a HASHSEP separated list of
directories in which to search. There is no default value.

=item SHELL

Set to the pathname of tpsh. Typically this is C</path/to/tpsh>. If no value
was set by the invocation environemt, then Perl's internal C<$0> variable will
be used.

=item TMPDIR, TEMP, TMP

A place where programs may store temporary files. TMPDIR is the Unix
convention, the other are used by Microsoft platforms.  tpsh will propagate
the first correct value to the other variables in the following order of
precedence: TMPDIR, TMP, TEMP.  Other wise there is no default value for these
variables.

=item TERM

Specifies the terminal type used. tpsh generally does not inspect TERM per se,
but will warn if it is not set, because many UNIX programs may rely on it (e.g.
vi).

=back

=head2 From tpsh

Unless pre-define din the invocation environment, these variables will always
be set by tpsh at startup.

=over 8

=item OSTYPE

Set to the value of Perl's C<$^O> variable. The value of OSTYPE may be used in
an ENV file to adjust itself based on the current operating system.

=item HASHSEP

Used as the field separator for hash-sep separated lists. Whenever an internal
operation accesses such data, the shell may modify this environment variable
with the corresponding compiled regular expression. The default value of
hash-sep is system dependent; currently if OSTYPE is C<MSWin32>, C<os2>, or
C<dos> the value of hash-sep is C<;>, other wise the unix convention of C<:>
will be assumed. 

=item EDITOR

The fall back editor used with the B<fc> built-in command. Many Unix programs
will also use EDITOR as the users default editor. The default value is system
dependent.

=item FCEDIT

The default editor used with the B<fc> built-in command.

=item IFS

The Input Field Separator (IFS) used by many internal operations. See the
L</XXX> section for more details. The default value is space, tab, and newline.
Nota Bene: this is expected to be a string, I<never> a perl regular expression.

=item PWD

The shells current working directory, as set by the B<cd> and B<chdir> built-in commands.

=item PS1

The string used as the primary command prompt. The default is C<$ >, unless you have a UID of 0, in which case it defaults to C<# >.

=item PS2

The secondary prompt string, used whenever tpsh requires additional information from the user. The default is C<<> >.

=item PS4

When the B<xtrace> option has been set in the shell, this string will be
prefixed to the trace output to aid debugging. For compatiblity with existing
shells (most of which are not purely compatible with IEEE Std 1003.1-2001
either), PS4 is used rather then a C<PS3>, The default value is C<+ >.

=item HISTSIZE

The number of lines to record in HISTFILE, looked up with the B<history> and
related built-in commands, etc. The default value is 512.

=item MAIL

Set but not used yet

=item TPSH_READLINE

Contains the name of the readline package being used by tpsh. You should be
able to look up the documentation for the current readline package with the
command `perldoc $TPSH_READLINE`. Potential values include Stubs, Gnu, Perl,
and Zoid.

=item TPSH_GLOB_FLAGS

A string in the format of 'FLAG1 | FLAG2' to apply to tpsh's file globing
behaviour, see L<File::Glob/POSIX FLAGS> for possible values. The default is
'GLOB_QUOTE | GLOB_TILDE'.

=back

=head2 From Profile/Runtime

These variables effect tpsh's behaviour, but will not be automatically set by tpsh.

=over 8

=item ENV

When invoking an interactive shells invocation, the ENV variable is interpreted
as a HASHSEP separated list of files to be sourced after any profile scripts.
The recommended value is F<${HOME}/.tpshrc>. See L</Invocation>

=item CDPATH

Search path used by the B<cd> and B<chdir> built-in commands, refer to
L</Built-in Commands> for a description of its side effects. There is no
default; the value of CDPATH should be a HASHSEP separated list.


=item HISTFILE

The file to save history to, and restore history from. There is no default.

=item TPSH_DOTDIR

A PATH like separated list, specifying the directories to search for F<tpsh_profile>s when starting a login shell. There is no default.

=back


=head1 FILES

F<filename>     what about it

=head1 EXIT STATUS

The progname utility exits 0 on success, and >0 if an error occurs.

=head1 SEE ALSO

L<sh(1)>, L<perl>, L<File::Glob>, L<Term::ReadLine>

=head1 HISTORY

=head1 CAVEATS & BUGS

The B<chdir> and B<cd> built-in commands delegate finding the users home
directory to the behaviour of Perl's chdir() function; it does not inspect
$HOME as C<sh> should. Like wise, $PWD is updated using the standard L<Cwd>
Perl module.

The B<pwd> built-in command is implemented using the Cwd Perl module, so C<pwd
-L> may behave differently in tpsh, then sh or /bin/pwd.

Operations that rely on time delays, via system calls such as sleep() or
alarm() may return early, late, or whatever strange behaviour can be
expected from your Operating System and Perl Distribution. The B<sleep> and
B<read> built-in commands are a prime example.

The value of the IFS variable is interpreted as a string not a regular
expression. This is intended and will not be changed. Note however, that
internally IFS is interpreted as /[IFS]/ with I<all> the implied implications;
but the author is not required to retain this behaviour: screw around at your
own risk.

The PS2 variable is not actually used yet, instead such things are delegated to
the L<Term::ReadLine> implementation for the time being.


Avid users of the GNU Bourne Again SHell (bash) should take note: while tpsh
implements the B<history> built-in command, no attempt is made to mimic the
functionality provided bash; use the provided built-ins. This is Terry's
Portable SHell after all, not a Bourne Again Clone :-P.

Most things say "meta character" or something similar, I say glob character:
it keeps it simple. Don't like my notation? Then write your own stinking
manual :-P.

The way the shells autohistory option is implemented; HISTFILE is loaded after
the users ENV, so they have a chance to change HISTFILE. Like wise it is saved
at shell exit through an END block in Perl, and subject to the usual rules that
implies. Obviously if you turn off the autohistory option before the shell
loads or during your ENV files, starting the shell with it enabled will do you
little good ;).

Currently the B<fc> built-in command handles I<first> and I<last> as array
subscripts or regular expressions; this means tpsh uses the same array indexing
behaviour as Perl, and provides the power of regular expressions which may or
may not be convenient at any given moment. Currently I<last> is always threated
as the same type as I<first>; which is not noted in the commands documentation
as this behaviour has not been decided yet.

Handling of history is still in development, so expect bugs.

The syntax of the B<alias> command is strange. It is generally impossible to
create a named macro with B<alias>: such as C<x=> by escaping the equal sign
with a backslash. A C-Shell style alias may contain an equal sign in the
definition, e.g. C<x =y z> because the Bourne shell syntax requires the equal
sign to follow a valid identifier. Thus any attempt at creating a macro like
C<x\= y z> shall have undefined results; and generally will NOT do what you
normally would expect.  Note: zsh also treats attempts to escape the equal sign
funny, but not quite in the same way as tpsh.

Anonymous macros/command grouping syntax and positional parameters are not
implemented yet.

Pipes were disabled ages ago.

I/O redirection probably only works with simple commands. Been to long since I
tested it that much.

The parse/lex/eval/cgen needs to do less split/join wrangling.

Job control is still pretty raw (and unix only) but seems functional.

Single quotes work like in programming, e.g. echo C<'foo \' bar'> is fine: it
is an error in Bourne shell.

=head1 LICENSE


                            "THE BEER-WARE LICENSE"

This file is was written by TerryP / BigBoss1964@gmail.com.  As long as you
retain this notice you can do whatever you want with this stuff. If we meet
some day, and you think this stuff is worth it, you can buy me a drink in
return.

=cut

