=pod

=head1 NAME

tpsh -- Terry's Portable SHell

=head1 SYNOPSIS

tpsh [-abCEefIimPpsuVvx] [-c string] [arg ...]

=head1 DESCRIPTION

=head2 Overview

=head2 Invocation

How tpsh behaves is dependent on how it was started, or "invoked" by the user.
When first starting up, tpsh will process its command line arguments for
options as explained below under L</Argument List Processing>. Any non options
remaining in the on the command line after this processing, are assumed to be
the names of shell scripts to be executed by the shell.

If tpsh is executing a shell script through a command line argument, it is
assumed to be a I<non-interactive> shell; otherwise if tpsh's standard input
is connected to a terminal or the B<-i> option was given: tpsh assumes it is
to behave as an I<interactive> shell should. A non-interactive shell reads
commands from the named files or standard input until receiving the end of
file marker.  An interactive shell initializes your systems L<Term::ReadLine>
module and displays a command prompt. Commands are read from standard input
until the shell is exited.

tpsh will always inspect the initial environment, and modify it accordingly
(see L</ENVIORNMENT>). tpsh then attempts to change to the users personal
directory, if running as an interactive shell, tpsh inspects the ENV
environment variable for shell initialization files. Interactive sessions then
process ENV if set, reading in each file as a script, before issuing the
prompt.
 
=head2 Argument List Processing


Since most of these options may be set either at invocation or at run time:
both the short and long names have been listed here for each option. The short
form may only be specified as a command line argument to tpsh. The long form
may be passed to the built-in set command using the -o/+o option to the set
command (described later in L</Built-in Commands>.)

=over 8

=item B<-a> allexport

Automatically export variables to the environment; i.e. C<FOO=BAR> has the same
effect as C<FOO=BAR; export FOO>.

=item B<-b> notify

Enable asynchronous notification of background job completion.

XXX not implemented yet

=item B<-C> noclobber

Do not overwrite existing files with I/O redirection; e.g. C<<cat f1 f2 > f1>>
becomes an error under noclobber.

=item B<-c string> 

Commands are read from the following argument (string) instead of from standard
input. Keep in mind that multi-word strings must be quoted in most shells.

XXX not implemented yet

=item B<-E> emacs

Use key bindings for interactive line editing that resemble the L<emacs(1)>
operating system. (This option counteracts -V)

XXX not implemented yet

=item B<-e> errexit

Exit the script immediately if any untested command fails. A command is
considered tested if it appears within a conditional statement or on the left
hand side of any logical operator, such as the C<&&> or C<||> operators.
Because user defined functions and aliases are mealy a form of textual macro,
the contents of any function is B<not> exempt from testing a commands exit
status..

XXX not implemented yet

=item B<-f> noglob

Disable filename globing; e.g. C<vi f*> passes the C<f*> to vi, rather then all
files matching the pattern.

=item B<-I> ignoreeof

Ignore end of file indicators from input when running in interactive mode. 

XXX not implemented yet

=item B<-i> interactive

Force th shell to execute in interactive mode.

=item B<-m> monitor

Enables built-in commands used for job control; e.g. fg, bg, jobs, etc.

XXX there is no job control yet

=item B<-n> noexec

if not interactive, read commands but do not execute them. Normally this is
used for checking a script for syntax errors without running it.

XXX not implemented yet

=item pathext

When executing commands, perform file extension checks before giving up.

=item reportpipe

Print an additional error message whenever SIGPIPE is received; default off.

=item B<-s> stdin

Read the commands from standard input (set automatically if there are no
command  line arguments left after option parsing).

=item B<-V> vi

Use key bindings for interactive line editing that resemble the L<vi(1)> text
editor. (This option counteracts -E)

XXX not implemented yet

=item B<-v> verbose

Before executing a command, write it to standard out; you may prefer the C<-x>
option for most situations.

=item B<-x> xtrace

Before executing a command, write it to standard error prefixed by the PS4
environment variable. More useful then the C<-v> option.


=back

=head2 Lexical Structure

=head2 Quoting Rules

=over 8

=item Single Quotes

=item Double Quotes

=item Backquotes (or backticks)

=back

=head2 Command Macros

Several features of other shells are considered by tpsh, to be a form of
command "Macro" for logical reasons (read: Terry's brain works this way). There
are 4 kinds of command macro, aliases, functions, and groups.

=head3 Anonymous Macros

An anonymous macro may be defined with the following syntax:

	{ commands }

Note that anonymous macros have access to the shells positional parameters,
unlike named macros which instead have localized positional parameters. The
content within the curly braces may contain anything that a named macro may /*
except things like local varname */

=head3 Named Macros

There are several ways to record a command macro for later use, a declaratory
syntax and an imperative syntax: often referred to as aliases and user defined
functions respectively.

=head4 Aliases

Command aliases provide a simple form of macro expansion at run time. An alias
is is defined with either of the following syntaxes:

	alias la='ls -a'
	alias ll 'ls -l'

The former is the Bourne syntax, while the latter is the CSH syntax. Simple
text substitution will replace 'la' with 'ls -a' and 'll' with 'ls -l' during
evaluation. An alias is functionally equivalent to the following statement:

	la() {
		ls -a
	}

Therefore any attempts to access the shells positional parameters ($1, $2, $*,
etc) from within an alias definition will instead access the positional
parameters of the macro. This allows one to define an alias such as:

	alias qux='qux -f $1 -ab $2'

and may be called like so:

	qux foo bar

with the following expansion:

	qux -f foo -ab bar

Note that the single quotes around the alias definition is important; single
quotes prevents tpsh from expanding the positional parameters B<before> storing
the alias. The right hand side of an alias definition is not treated specially,
and therefore obeys the shells usual quoting schematics.

=head4 User Defined Functions

A named macro may also be defined as if it were a function:

=over 8

=item Bourne Again syntax

	[function] name() command

The definition of C<command> may be any simple command or anonymous macro body.

=item Terry's syntax

	macro name( commands )

=back

The macro then can be executed by invoking C<name> as if it were a simple
command. The primary distinction between aliases and user defined functions,
is only a matter of syntax: they are B<functionally> equivalent macros.


Arguments are passed to a user defined function (named macro) by localizing the
shells positional parameters to the currently executing macro; thus in the
above example the C<$0> parameter would expand to C<name> rather then C<tpsh>.
When using the Bourne style of defining a function, often the C<command>
portion is a list of commands grouped within curly braces: in tpsh this context
is what gives macro its name, therefore it is no longer anonymous and receives
localized positional parameters in order to simulate C<function arguments>.


=head3 Example Macros

	alias lf=ls -f
	alias pgr less
	macro cvs-st(cvs status | grep -i Status:)
	function new-script() {
		echo '#!/usr/bin/env' " $1\n\n" >> $2
	}

=head2 Built-in Commands

=over 8

=item B<alias> [I<name>=I<string> | I<name string>]

Creates a named macro or C<alias> with name and definition I<string>. Both the
Bourne and C-Shell syntaxes are emulated (respectively). When using the first
form, the string value should be quoted to ensure the that macro expansion
occurs at the desired time (i.e. run time or allocation). For one line
expressions, you may find the C-Shell syntax or tpsh's B<macro> built-in more
convenient; for more complex expressions the B<function> built-in is better
suited to created a named macro then the B<alias> built-in. If I<name> is
specified without any definition, then the definition of macro I<name> will be
displayed if it exists; without any arguments, the B<alias> command displays
all named macros in a format then can easily be processed by L<awk(1)>.

=item B<builtin> I<command> [I<arg ...>]

Execute built-in command I<command> with specified arguments. If you have
overridden a built-in command using a macro, you can still use the built-in by
invoking it through the B<builtin> built-in command, are you tongue twisted
yet?

=item B<cd> [I<directory>]

Change the shells current working directory to the specified directory, or to
the users HOME directory if no directory was specified. When the CDPATH
environment variable is set, and I<directory> does not begin with /, ., or ..,
then the directories listed in CDPATH will be searched for the specified
directory.  If CDPATH is unset, then only the current directory is searched.
The format of CDPATH is explained in L</ENVIRONMENT>.

=item B<exec> I<command> [I<args ...>]

The shell will replace itself with the specified I<command> using the L<exec>
function. I<Command> can not be a shell built-in or macro.

=item B<chdir> [I<directory>]

A synonym for the B<cd> built-in command.

=item B<cls>

Attempt to clear the terminal screen. If your perl distrubtion supports the
L<Term::Cap> module correctly, the usual unix convention is used; other wise
enough whitespace will be generated for the average display.

=item B<exit> [I<status>]

Exit the shell with exit status I<status>, if status is omitted then the exit
status of the last command is used. Note that I<status> should be an integer.

=item B<function> I<name()> [I<list ...>]

Defines a named macro using syntax that resembles the GNU Bourne Again SHell.
I<List> may be any simple or grouped command. Defining a complex or multi-line
function is best done by binding I<name()> to an anonymous macro; which is done
by using {} or () grouping. For short (i.e. one line) macros, you may find the
B<macro> built-in to be a more concise notation. See L</Command Macros>.

=item B<hash> [B<-r>] [I<command ...>]

Displays the shells internal hash table of C<command=/path/to/command>, which
is used for caching the value of the PATH environment variable. Any arguments
given to the B<hash> built-in command, are assumed to be the name of a program
found in the users PATH, which is to be removed from the shells hash table. If
the B<-r> option is specified, then delete the entire contents of the hash
table.  Note well that this does I<not> allow you to remove a single command
from your search PATH, it only manipulates internal data structures used to
speed up command execution. 

=item B<macro> I<name(> [<command ...>] I<)>

Defines a named macro using a tpsh specific syntax. There must be a space after
the opening parentheses, and if I<command> is given there must also be a space
before the closing parentheses. An empty macro may be defined as C<macro
name()>, but not C<macro name()>. I<Command> may be any arbitrary command line
(similar to what the B<eval> built-in command accepts), and will be stored as a
named macro with I<name>. See L</Command Macros>.

=item B<pwd> [B<-L> | B<-P>]

A built in function for printing the current working directory. If the B<-P>
option is specified, print the current working directories real path; if the
B<-L> option is specified, print the shells idea of its current working
directory.  The B<-L> option is the default behaviour.

=item B<read> [B<-p> I<prompt>] [B<-t> I<timeout>] I<variable ...>]

Read a line from standard input, split by fields, and assign each field to the
indicated I<variable>s. If the number of variables is less then the number of
fields, the remaining fields will be stored 'as is' in the last variable. If
there are more variables then fields, the excess variables will be defined with
empty strings. A prompt may be printed before reading input, by using the B<-p>
option. The B<-t> option may be used to specify a timeout in which to abort the
operation, should the user take their sweet time about pressing CR. The
I<timeout> value can take an optional C<s>, C<m>, or C<h> suffix to denote
seconds, minutes, or hours. If no suffix is given, C<s> will be assumed.

=item B<set> [B<-/+abCEefIimVvx>] [B<-/+o> I<longname>] [B<-c> I<string>] [B<--> I<arg ...>]

If no options are given, the B<set> command displays the values of all shell
variables.

If options are given using either short form or the C<-/+o logname> form; it
sets or clears the specified options as described in the above section
L</Argument List Processing>. Introducing an option with a dash (C<->) enables
the option, while using a plus (C<+>) disables the option.  A C<--> or plain
C<-> will stop option processing and will force the remaining words on the
command line to be treated as arguments.

If the B<--> option is specified or only bare words are given, set will replace
the shells positional parameters with whatever arguments follow. If no
arguments follow the B<--> option, all the positional parameters will be
cleared, as if the user had executed C<shift $#>.

=item B<sleep> I<timespec>

Causes tpsh to pause execution for I<timespec> using the L<sleep> system call.
The I<timespec> is assumed to be an integer number of seconds to sleep. An
optional suffix of C<s>, C<m>, or C<h> can be used to denote seconds, minutes,
or hours.

=item B<type> [I<name ...>]

Interpret each I<name> as a command, then print the result. Possible types are:
built-in command, command, macro, or not found. For convenience, if an
executable is found in the current directory tpsh will print C<command may be
$PWD/command> before giving up. For macros, the stored definition is printed;
for command, the complete pathname is printed; for built-in command, tsph will print command is a shell builtin.

=item B<which> [B<-as>] [B<--all> | B<--silent>] I<command ...>

Check for the presence of I<command> by searching the users PATH environment
variable. The result of the search is then printed to standard output, subject
to the options given by the user. I<Command> may be a built-in command, macro,
or the name of a program without a path (e.g. C<ls>). If the B<-s> option is
specified, return 0 if all commands were found, and 1 otherwise; but do not
generate I<any> output. If the B<-a> option is specified, continue searching
after command has been found, printing all occurrences to standard output. Nota
Bene: for compatiblity with other traditional implementationsshells, B<which>
does not interprete the users PATHEXT variable or the shells pathext option;
use B<type> instead.
 
=back

=head1 ENVIRONMENT

Environment variables may be broken down into variables that I<should> be
inheritied from the invocation environment, variables set by tpsh on startup,
and variables that are not automatically set; but never the less have
significance to tpsh's behaviour. Most variables will retain their original
value if found in tpsh's invocation environment.

An environment variable is set if it contains an string or numeric value.
Variables may be unset by setting them to the empty string, or by using the
B<unset> built-in command.  

=head2 From Invocation Environment

These variables should be inherited by tpsh at startup, if not they will be
initialized to sane values as noted below. 

=over 8

=item USER, LOGNAME, USERNAME

The name of the currently logged in user. One of these variables must be set by
the operating system before the shell is executed, then tpsh will set the other
variables to match unless they already exist. If I<none> of these variables have
been set by the invocation environment, tpsh will pop a cork.

=item HOME, HOMEPATH, USERPROFILE

The path to the users personal or C<home> directory, and tpsh's default
starting directory. tpsh will attempt to set these variables to the correct
values if necessary.

=item PATH

The default search path for executables. PATH is a HASHSEP delimited list of
directories in which to search. The default value is system dependent.

=item SHELL

Set to the pathname of tpsh. Typically this is C</path/to/tpsh>. If no value
was set by the invocation environemt, then Perl's internal C<$0> variable will
be used.

=item TMPDIR, TEMP, TMP

A place where programs may store temporary files. TMPDIR is the Unix
convention, the other are used by Microsoft platforms.  tpsh will proprogate
the first correct value to the other variables in the following order of
precedence: TMPDIR, TMP, TEMP.  Other wise there is no default value for these
variables.

=item TERM

Specifies the terminal type used. tpsh generally does not inspect TERM per se,
but will warn if it is not set, because many UNIX programs may rely on it (e.g.
vi).

=back

=head2 From tpsh

Unless pre-define din the invocation environment, these variables will always
be set by tpsh at startup.

=over 8

=item OSTYPE

Set to the value of Perl's C<$^O> variable. The value of OSTYPE may be used in
an ENV file to adjust itself based on the current operating system.

=item HASHSEP

Used as the field separator for hash-sep delimited lists. Whenever an internal
operation accesses such data, the shell may modify this environment variable
with the corrisponding compiled regular expression. The default value of
hash-sep is system dependent; currently if OSTYPE is C<MSWin32>, C<os2>, or
C<dos> the value of hash-sep is C<;>, other wise the unix convention of C<:>
will be assumed. 

=item EDITOR

The fall back editor used with the B<fc> built-in command. Many Unix programs
will also use EDITOR as the users default editor. The default value is system
dependent.

=item FCEDIT

The default editor used with the B<fc> built-in command.

=item IFS

The Input Feild Separator (IFS) used by many internal operations. See the
L</XXX> section for more details. The default value is space, tab, and newline.
Nota Bene: this is expected to be a string, I<never> a perl regular expression.

=item PWD

The shells current working directory, as set by the B<cd> and B<chdir> built-in commands.

=item PS1

The string used as the primary command prompt. The default is C<$ >, unless you have a UID of 0, in which case it defaults to C<# >.

=item PS2

The secondary prompt string, used whenever tpsh requires additional information from the user. The default is C<<> >.

=item PS4

When the B<xtrace> option has been set in the shell, this string will be
prefixed to the trace output to aid debugging. For compatiblity with existing
shells (most of which are not purely compatible with IEEE Std 1003.1-2001
either), PS4 is used rather then a C<PS3>, The default value is C<+ >.

=item HISTSIZE

The number of lines to record in HISTFILE, looked up with the B<history> and
related built-in commands, etc. The default value is 512.

=item MAIL

Set but not used yet

=item TPSH_READLINE

Contains the name of the readline package being used by tpsh. You should be
able to look up the documentation for the current readline package with the
command `perldoc $TPSH_READLINE`. Potentional values include Stubs, Gnu, Perl,
and Zoid.

=item TPSH_GLOB_FLAGS

A string in the format of 'FLAG1 | FLAG2' to apply to tpsh's file globbing
behaviour, see L<File::Glob/POSIX FLAGS> for possible values. The default is
'GLOB_QUOTE | GLOB_TILDE'.

=back

=head2 From Profile/Runtime

These variables effect tpsh's behaviour, but will not be automatically set by tpsh.

=over 8

=item ENV

When invoking an interactive shells invocation, the ENV variable is interpreted
as a HASHSEP delimited list of files to be sourced after any profile scripts.
The reccomended value is F<${HOME}/.tpshrc>. See L</Invocation>

=item CDPATH

Search path used by the B<cd> and B<chdir> built-in commands, refer to
L</Built-in Commands> for a discription of its side effects. There is no
default; the value of CDPATH should be a HASHSEP delimited list.


=item HISTFILE

The file to save history to, and restore history from. There is no default.

=item TPSH_DOTDIR

A PATH like delimited list, specifing the directories to search for F<tpsh_profile>s when starting a login shell. There is no default.

=back


=head1 FILES

F<filename>     what about it

=head1 EXIT STATUS

The progname utility exits 0 on success, and >0 if an error occurs.

=head1 SEE ALSO

L<sh(1)>, L<perl>, L<File::Glob>, L<Term::ReadLine>

=head1 HISTORY

=head1 CAVEATS & BUGS

The B<chdir> and B<cd> built-in commands delegate finding the users home
directory to the behaviour of Perl's chdir() function; it does not inspect
$HOME as C<sh> should. Like wise, $PWD is updated using the standard L<Cwd>
Perl module.

The B<pwd> built-in command is implemented using the Cwd Perl module, so C<pwd
-L> likely will behave differently in tpsh, then sh or /bin/pwd.

Operations that rely on time delays, via system calls such as sleep() or
alarm() may return early, late, or whatever strange behaviour can be
expected from your Operating System and Perl Distribution. The B<sleep> and
B<read> built-in commands are a prime example.

The value of the IFS variable is interpreted as a string not a regular
expression. This is intended and will not be changed. Note however, that
internally IFS is interpreted as /[IFS]/ with I<all> the implied implications;
but the author is not required to retain this behaviour: screw around at your
own risk.

The PS2 variable is not actually used yet, instead such things are delegated to
the L<Term::ReadLine> implementation for the time being.


Avid users of the GNU Bourne Again SHell (bash) should take note: while tpsh
implements the B<history> built-in command, no attempt is made to mimic the
functionality provided bash; use the provided built-ins. This is Terry's
Portable SHell after all, not a Bourne Again Clone :-P.

=head1 LICENSE


                            "THE BEER-WARE LICENSE"

This file is was written by TerryP / BigBoss1964@gmail.com.  As long as you
retain this notice you can do whatever you want with this stuff. If we meet
some day, and you think this stuff is worth it, you can buy me a drink in
return.

=cut

