=pod

=head1 NAME

tpsh -- Terry's Portable SHell

=head1 SYNOPSIS

tpsh [-abCEefIimPpsuVvx] [-c string] [arg ...]

=head1 DESCRIPTION

=head2 Overview

=head2 Invocation

=head2 Argument List Processing


Since most of these options may be set either at invocation or at run time:
both the short and long names have been listed here for each option. The short
form may only be specified as a command line argument to tpsh. The long form
may be passed to the built-in set command using the -o/+o option to the set
command (described later in L</Built-in Commands>.)

=over 8

=item B<-a> allexport

Automatically export variables to the environment; i.e. C<FOO=BAR> has the same effect as C<FOO=BAR; export FOO>.

=item B<-b> notify

Enable asynchronous notification of background job completion.

=item B<-C> noclobber

Do not overwrite existing files with I/O redirection; e.g. C<<cat f1 f2 > f1>> becomes an error under noclobber.

=item B<-c string> 

Commands are read from the following argument (string) instead of from standard input. Keep in mind that multi-word strings must be quoted in most shells.


=item B<-E> emacs

Use key bindings for interactive line editing that resemble the L<emacs(1)> operating system. (This option counteracts -V)

=item B<-e> errexit

Exit the script immediately if any untested command fails. A command is considered tested if it appears within a conditional statement or on the left hand side of any logical operator, such as the C<&&> or C<||> operators. Because user defined functions and aliases are mealy a form of textual macro, the contents of any function is B<not> exempt from testing a commands exit status..

=item B<-f> noglob

Disable filename globing; e.g. C<vi f*> passes the C<f*> to vi, rather then all files matching the pattern.

=item B<-I> ignoreeof

Ignore end of file indicators from input when running in interactive mode. 

=item B<-i> interactive

Force th shell to execute in interactive mode.

=item B<-m> monitor

Enables built-in commands used for job control; e.g. fg, bg, jobs, etc.

XXX there is no job control yet

=item B<-n> noexec

if not interactive, read commands but do not execute them. Normally this is used for checking a script for syntax errors without running it.

XXX not implemented yet

=item B<-s> stdin

Read the commands from standard input (set automatically if there are no command  line arguments left after option parsing).

=item B<-V> vi

Use key bindings for interactive line editing that resemble the L<vi(1)> text editor. (This option counteracts -E)

=item B<-v> verbose

Before executing a command, write it to standard out; you may prefer the C<-x> option for most situations.

=item B<-x> xtrace

Before executing a command, write it to standard error prefixed by the PS4 environment variable. More useful then the C<-v> option.


=back

=head2 Lexical Structure

=head2 Quoting Rules

=over 8

=item Single Quotes

=item Double Quotes

=item Backquotes (or backticks)

=back

=head2 Command Macros

Several features of other shells are considered by tpsh, to be a form of command "Macro" for logical reasons (read: Terry's brain works this way). There are 4 kinds of command macro, aliases, functions, and groups.

=head3 Anonymous Macros

An anonymous macro may be defined with the following syntax:

	{ commands }

Note that anonymous macros have access to the shells positional parameters, unlike named macros which instead have localized positional parameters. The content within the curly braces may contain anything that a named macro may /* except things like local varname */

=head3 Named Macros

There are several ways to record a command macro for later use, a declaratory syntax and an imperative syntax: often referred to as aliases and user defined functions respectively.

=head4 Aliases

Command aliases provide a simple form of macro expansion at run time. An alias is is defined with either of the following syntaxes:

	alias la='ls -a'
	alias ll 'ls -l'

The former is the Bourne syntax, while the latter is the CSH syntax. Simple text substitution will replace 'la' with 'ls -a' and 'll' with 'ls -l' during evaluation. An alias is functionally equivalent to the following statement:

	la() {
		ls -a
	}

Therefore any attempts to access the shells positional parameters ($1, $2, $*, etc) from within an alias definition will instead access the positional parameters of the macro. This allows one to define an alias such as:

	alias qux='qux -f $1 -ab $2'

and may be called like so:

	qux foo bar

with the following expansion:

	qux -f foo -ab bar

Note that the single quotes around the alias definition is important; single quotes prevents tpsh from expanding the positional parameters B<before> storing the alias. The right hand side of an alias definition is not treated specially, and therefore obeys the shells usual quoting schematics.

=head4 User Defined Functions

A named macro may also be defined as if it were a function:

=over 8

=item Bourne Again syntax

	[function] name() command

The definition of C<command> may be any simple command or anonymous macro body.

=item Terry's syntax

	macro name( commands )

=back

The macro then can be executed by invoking C<name> as if it were a simple command.  The primary distinction between aliases and user defined functions, is only a matter of syntax: they are B<functionally> equivalent macros.


Arguments are passed to a user defined function (named macro) by localizing the shells positional parameters to the currently executing macro; thus in the above example the C<$0> parameter would expand to C<name> rather then C<tpsh>. When using the Bourne style of defining a function, often the C<command> portion is a list of commands grouped within curly braces: in tpsh this context is what gives macro its name, therefore it is no longer anonymous and receives localized positional parameters in order to simulate C<function arguments>.


=head3 Example Macros

	alias lf=ls -f
	alias pgr less
	macro cvs-st(cvs status | grep -i Status:)
	function new-script() {
		echo '#!/usr/bin/env' " $1\n\n" >> $2
	}

=head2 Built-in Commands

=over 8

=item B<set [-/+abCEefIimVvx] [-/+o longname] [-c string] [-- arg ...]

If no options are given, the set command displays the values of all shell variables.

If options are given using either short form or C<-/+o logname> form; it sets
or clears the specified options as described in the above section L</Argument
List Processing>. Introducing an option with a dash (C<->) enables the option,
while using a plus (C<+>) disables the option.  A C<--> or plain C<-> will stop
option processing and will force the remaining words on the command line to be
treated as arguments.

If the C<--> option is specified or only bare words are given, set will replace the shells positional parameters with whatever arguments follow. If no arguments follow the C<--> option, all the positional parameters will be cleared, as if the user had executed C<shift $#>.

=back

=head1 FILES

F<filename>     what about it

=head1 EXIT STATUS

The progname utility exits 0 on success, and >0 if an error occurs.

=head1 SEE ALSO

L<sh(1)>, L<perl(1)>, L<File::Glob>, L<Term::ReadLine>

=head1 HISTORY

head1 CAVEATS & BUGS

If the command is equal to 'unalias', it's arguments up until a command terminator (such as ;, |, >, ), or }) are not subject to macro expansion; note that parameter expansion is still performed.

=head1 LICENSE


                            "THE BEER-WARE LICENSE"

This file is was written by TerryP / BigBoss1964@gmail.com.  As long as you
retain this notice you can do whatever you want with this stuff. If we meet
some day, and you think this stuff is worth it, you can buy me a drink in
return.

=cut

