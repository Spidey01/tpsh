#!/usr/bin/env perl
#
# Terry's Portable SHell
#
#--------------------------------------------------------------------

use warnings;
use strict;


use Cwd;
use Dumpvalue;
use File::Basename;
use File::Glob          ':glob';
use File::Spec;
use File::Temp;
use FindBin;
use Getopt::Long;       # do NOT export GetOptionsFrom*
use POSIX               (); # this should work on unix and windows but idk about other platforms.
use Term::ReadLine;

#
# override $0 for the entire script
#
FindBin::again(); 
local $0 = File::Spec->catfile($FindBin::Bin, $FindBin::Script);

#----------------------------------------------------------
#                Subroutine Prototypes
#----------------------------------------------------------

#
# Internal subroutines
#
sub init_sh;
sub init_os;
sub init_os_unix;
sub init_os_windows;
sub init_readline;
sub init_job_control;
sub init_job_control_unix;
sub init_job_control_windows;
sub do_getop;
sub main_loop;
sub tpsh_parse;
sub tpsh_lex;
sub tpsh_cgen;
sub resolve_cmd;
sub exec_cmd;
sub wait_for_job;
sub wait_for_job_unix;
sub wait_for_job_windows;
sub give_term;
sub give_term_unix;
sub give_term_windows;
sub exec_job;
sub pexec;
sub search_path;
sub execute;
sub handle_prompt;
sub rehash;
sub update_env;
sub sh_eval;
sub do_completion;
sub complete_filename;
sub complete_command;
sub complete_macro;
sub complete_variable;
sub complete_builtin;
sub expand_quotes;
sub expand_tilde;
sub expand_parameters;
sub mark_parameters;
sub expand_backticks;
sub mark_backticks;
sub expand_aliases;
sub expand_glob;
sub exec_pipe;
sub get_history;
sub add_history;
sub load_history;
sub save_history;
sub binerr;
sub hsplit;
sub ifsplit;
sub is_macro;
sub is_builtin;
sub err_handler;
sub death_handler;
sub min;
sub max;
sub igrep;
sub tempfile;
sub make_job;
sub print_job;
sub dump_job_status;
sub get_job;
sub save_term_state;
sub save_term_state_unix;
sub save_term_state_windows;
sub restore_term_state;
sub restore_term_state_unix;
sub restore_term_state_windows;
#
# These subs implement built in commands
#
sub alias_bin;
sub bg_bin;
sub builtin_bin;
sub cd_bin;
sub cls_bin;
sub dirs_bin;
sub echo_bin;
sub eval_bin;
sub exit_bin;
sub export_bin;
sub false_bin;
sub fc_bin;
sub fg_bin;
sub function_bin;
sub hash_bin;
sub history_bin;
sub loadhist_bin;
sub macro_bin;
sub macros_bin;
sub popd_bin;
sub pushd_bin;
sub pwd_bin;
sub read_bin;
sub rehash_bin;
sub savehist;
sub set_bin;
sub setenv_bin;
sub setvar_bin;
sub sleep_bin;
sub source_bin;
sub test_bin;
sub times_bin;
sub trap_bin;
sub true_bin;
sub type_bin;
sub unalias_bin;
sub unset_bin;
sub which_bin;

#----------------------------------------------------------
#                Global Data Structures
#----------------------------------------------------------

#
# Represents command line flags and set -options
#
my %Options = (
    allexport       =>  0,
    autohistory     =>  0,
    notify          =>  0,
    noclobber       =>  0,
    debug           =>  0,
    emacs           =>  1,
    errexit         =>  0,
    noglob          =>  0,
    ignoreeof       =>  0,
    interactive     =>  0,
    monitor         =>  0,
    noexec          =>  0,
    privileged      =>  0,
    pathext         =>  1,
    reportpipe      =>  0,
    stdin           =>  0,
    vi              =>  0,
    verbose         =>  0,
    xtrace          =>  0,
    #
    # This next option is used for things like tpsh -c "str"; do not document 
    # this as a set -/+o option
    # because it should never be used that way!
    #
    cmdstr          =>  '',
);

#
# Hashref for updating %Options through Getopt::Long / do_getopt()
#
my $Setopts = {
    'a|allexport'    =>  \$Options{allexport},
    'A|autohistory'  =>  \$Options{autohistory},
    'b|notify'       =>  \$Options{notify},
    'c|command=s'    =>  \$Options{cmdstr},
    'C|noclobber'    =>  \$Options{noclobber},
    'D|debug'        =>  \$Options{debug},
    'E|emacs'        =>  \$Options{emacs},
    'e|errexit'      =>  \$Options{errexit},
    'f|noglob'       =>  \$Options{noglob},
    'I|ignoreeof'    =>  \$Options{ignoreeof},
    'i|interactive'  =>  \$Options{interactive},
    'm|monitor'      =>  \$Options{monitor},
    'o:s'            =>  sub {
                             my @opts = keys %Options;
                             my $flags = $_[1];

                             # set -o = pretty print
                             if (length($flags) == 0) {
                                 my ($o, $v);
                                 format = 
@<<<<<<<<<<<<<<<    @<<<
$o, $v
.
                                 foreach $o (@opts) {
                                     # print $o, "\t",
                                           # ($Options{$o} == 0 ? "off"
                                                              # : "on"), "\n";
                                    $v = $Options{$o} ? "on" : "off";
                                    write();
                                 }
                                 return;
                             }
                             
                             # set -o [opt,list] = d'uh
                             for my $o (split /,/, $flags) {
                                 grep /$o/, @opts or
                                    die("no such option: $o"), last;
                                 $Options{$o} = 1;
                             }
                         },
    'p|privileged'   =>  \$Options{privileged},
    'reportpipe'     =>  \$Options{reportpipe},
    's|stdin'        =>  \$Options{stdin},
    'V|vi'           =>  \$Options{vi},
    'v|verbose'      =>  \$Options{verbose},
    'x|xtrace'       =>  \$Options{xtrace},
    #---
    #'h'              =>   \&pod2usage(-verbose => 0, -exitval => 1),
    #'help'           =>   \&pod2usage(-verbose => 1, -exitval => 1),
    #'m|man'          =>   \&pod2usage(-verbose => 3, -exitval => 0),
};


#
# Used whenever split /sep/, "foosepbar" is needed. I.e. $PATH, $CDPATH.
# init_sh will initialize and compile this as a regular expression appropirate
# for the users operating system, i.e. ':' or ':'.
#
# You should use hsplit(LIST) instead of directly using this with split 
#
my $HashSep = \$ENV{HASHSEP};

#
# Introspector / debugging aid.
#
my $Dumper = new Dumpvalue;

#
# Holds the last executed command, usually built in.
#
my $Last_Cmd = '';

#
# Holds the last parsed line of input
#
my @Last_Line = ();

#
# Internal history buffer, holds individual command lines sans the '\n'.
# This is used if the ReadLine module doesn't support history. You should
# never access this directly, use the main::*_history() functions here.
# note: generally this is here so things like fc still work with when
# Term::ReadLine::Stubs is the only readline module available.
#
my @History = ();

#
# In an interactive shell, this holds the number of command lines that have
# been entered by the user. If you call get_history() to get a list of lines
# within HISTSIZE, you can find your numerical indexs starting point within 
# the global history as $#get_history() - $HistoryNumber. 
#
my $HistoryNumber = 1;

#
# Reference to our ReadLine interface
#
my $Term;

#
# Reference to our terminal state for use with save_term_states and
# restore_term_state.
#
# On unix:      this will be a POSIX::Termios object.
# On windows:   this is currently unused.
#
#
my $TermState;

#
# A hash containing a cache of all known commands, in the format
# of command => /path/to/command. Only the rehash() sub should
# ever modify this cache directly!
#
my %Path = ();

#
# A hash of the users macros in macro => expression format.
# The macros are kept separate from %Builtins, so the user
# can _not_ clobber builtin commands; only mask them.
#
my %Macros = ();

#
# A hash of built in commands in the format of command => sub.
# Each handler should be named command_bin for consistency. For 
# security reasons, you should never modify this hash at runtime.
#
my %Builtins = ( '.'            => \&source_bin,
                 '['            => sub { warn "Not implemented\n" },
                 'alias'        => \&alias_bin,
                 'bg'           => \&bg_bin,
                 'bindkey'      => sub { warn "Not implemented\n" },
                 'builtin'      => \&builtin_bin,
                 'cd'           => \&cd_bin,
                 'chdir'        => \&cd_bin,
                 'cls'          => \&cls_bin,
                 'command'      => sub { warn "Not implemented\n" },
                 'dirs'         => \&dirs_bin,
                 'echo'         => \&echo_bin,
                 'eval'         => \&eval_bin,
                 'exec',        => \&exec_bin,
                 'exit'         => \&exit_bin,
                 'export'       => \&export_bin,
                 'false'        => \&false_bin,
                 'fc'           => \&fc_bin,
                 'fg'           => \&fg_bin,
                 'function'     => \&function_bin,
                 'getopts'      => sub { warn "Not implemented\n" },
                 'hash'         => \&hash_bin,
                 'history'      => \&history_bin,
                 'jobs'         => \&jobs_bin,
                 'loadhist'     => \&loadhist_bin,
                 'local'        => sub { warn "Not implemented\n" },
                 'macro'        => \&macro_bin,
                 'macros'       => \&macros_bin,
                 'popd'         => \&popd_bin,
                 'pushd'        => \&pushd_bin,
                 'pwd'          => \&pwd_bin,
                 'read'         => \&read_bin,
                 'readonly'     => sub { warn "Not implemented\n" },
                 'rehash'       => \&rehash_bin,
                 'return'       => sub { warn "Not implemented\n" },
                 'savehist'     => \&savehist_bin,
                 'set'          => \&set_bin,
                 'setenv'       => \&setenv_bin,
                 'setvar'       => \&setvar_bin,
                 'shift'        => sub { warn "Not implemented\n" },
                 'sleep'        => \&sleep_bin,
                 'source'       => \&source_bin,
                 'test'         => \&test_bin,
                 'times'        => \&times_bin,
                 'trap'         => \&trap_bin,
                 'true'         => \&true_bin,
                 'type'         => \&type_bin,
                 'ulimit'       => sub { warn "Not implemented\n" },
                 'umask'        => sub { warn "Not implemented\n" },
                 'unalias'      => \&unalias_bin,
                 'unset'        => \&unset_bin,
                 'wait'         => sub { warn "Not implemented\n" },
                 'which'        => \&which_bin,
);

#
# A hash of active jobs.
#
# Job ID's are used for keys.
#
use Class::Struct Job => {
    jid => '$',
    pgid => '$',
    pid => '$',
    argv => '@',
    state => '$',
    fd => '$',
};
my %Jobs = ();

#
# Last active job. Invalid until job control is initialized.
#
my $Last_Job;

#
# File handle for the currently executing script.
# TODO:
#   replace this with the tpsh job's file handle, even when job control is off.
my $ScriptHandle = undef;

#----------------------------------------------------------
#                Subroutine Implementations
#----------------------------------------------------------

=pod

init_platform

Initialize platform specific functions that are really providied by an implementation specific to $^O.

=cut

sub init_platform {
    my $p = 'port me';
    my %oses = (
        MSWin32 => 'windows',
        os2 => $p, 
        dos => $p,
        VMS => $p,
        MacOS => $p,
        NetWare => $p,
        beos => $p,
        vos => $p,
    );
    my @funcs = qw(
        init_os
        init_job_control
        give_term
        wait_for_job
        save_term_state
        restore_term_state
    );

    my $os = exists($oses{$^O}) ? $oses{$^O} : 'unix';
    if ($os eq $p) {
        warn "Unsupported OS $^O -- YMMV without porting!\n";
        eval "*$_ = sub { warn 'Please $p to $^O'; }" foreach @funcs;
    } else {
        if ($Options{debug}) {
            print "*$_ = \\&${_}_$os;\n" foreach @funcs;
        }
        eval "*$_ = \\&${_}_$os;" foreach @funcs;
    }

}


=pod

init_sh

Get the shell up and running.  -> this is one _huge_ ass sub

=cut

sub init_sh {
    # override warn/die behaviour with the desired output
    #
    $SIG{__WARN__} = \&err_handler;
    $SIG{__DIE__}  = \&death_handler;

    init_platform();

    $ENV{OSTYPE} = $^O;

    # sets the following:
    #   $LOGNAME
    #   $UID
    #   $HOME
    #   $EDITOR
    #   $HASHSEP
    #
    init_os();
    foreach (qw(LOGNAME UID HOME)) {
        die "$_ environment variable not set" unless defined $ENV{$_};
    }

    # for compatability with Windows NT and BSD UNIX
    $ENV{USERNAME} = $ENV{USER} = $ENV{LOGNAME};

    # There can only be one value!
    if (defined $ENV{TMPDIR}) {
        $ENV{TMP}   ||= $ENV{TMPDIR};
        $ENV{TEMP}  ||= $ENV{TMPDIR};
    } else {
        $ENV{TMPDIR} ||= $ENV{TMP} || $ENV{TEMP};
        $ENV{TMP}    ||= $ENV{TMPDIR};
        $ENV{TEMP}   ||= $ENV{TMPDIR};
    }

    # some programs (e.g. nvi) will pop a cork if TMPDIR=""
    # so delete them all, unless there is a value.
    unless (defined $ENV{TMPDIR}) {
        delete @ENV{qw/TMPDIR TMP TEMP/};
    }

    #
    # O.K. now on to [default] shell settings.
    #
    $ENV{HISTSIZE}  ||= 512;
    $ENV{IFS}       ||= " \t\n";
    $ENV{PS1}       ||= $ENV{UID} != 1 ? '$ ' : '# ';
    $ENV{PS2}       ||= '> ';
    $ENV{PS4}       ||= '+ ';
    $ENV{SHELL}     ||= $0;             #  don't use $pw to get shell.

    # Set defaults for shell globbing behavour
    #
    $ENV{TPSH_GLOB_FLAGS} ||= 'GLOB_QUOTE | GLOB_TILDE';

    # PID
    $ENV{'$'} = $$;

    # other special variables
    for (my $i=0; $i <= $#ARGV; ++$i) {
        $ENV{$i} = $ARGV[$i];
    }
    $ENV{'*'} = join(' ', @ARGV);
    $ENV{'#'} = $#ARGV + 1;

    if (defined $ENV{0}) {
        open $ScriptHandle, $ENV{0} or die $!;
    }

    init_job_control() if $Options{monitor};

    if ($Options{interactive}) {
        # change to the users home directory by default.
        # this will also take care of the OLDPWD/PWD variables.
        #
        cd_bin $ENV{HOME};
        $ENV{DIRSTACK} = "~";
    } else {
        # scripts/commands run from CWD.
        $ENV{PWD} = $ENV{DIRSTACK} = Cwd::getcwd();
    }

    init_readline();

    # call now, so any default $PATH is pre-hashed for the users $ENV scripts
    rehash();

    # process the users ENV files
    #
    if ($Options{interactive}) {
        if (exists $ENV{ENV}) {
            foreach (hsplit $ENV{ENV}) { 
                my $f = sh_eval $_;
                source_bin $f or warn "$f: $!";
            }
        }
    }
}

# sub init_os {
    # warn "TODO: implement init_os for $^O";
# }

sub init_os_windows {
    # Does MS Windows specific initializations

    $$HashSep       ||= qr';';
    $ENV{EDITOR}    ||= 'edit';

    # ActivePerl bundles this, Strawberry doesn't. So eval it.
    my %pw;
    eval {
        require Win32API::Net;
        Win32API::Net::UserGetInfo('', $ENV{USERNAME}, 3, my $href={}) 
            || die $!;

        $ENV{LOGNAME} = $href->{name};
        $ENV{UID} = $href->{userId};
        $ENV{HOME} = $href->{homeDir} || $ENV{USERPROFILE};
    };

    return unless $@;

    # We will just have to guess... bah!

    $ENV{LOGNAME} = $ENV{USERNAME};
    $ENV{UID} = $<;
    $ENV{HOME} = $ENV{USERPROFILE};
}

sub init_os_unix {
    # Does UNIX specific initializations

    # ignore ^Z/SUSP key for now: job control not enabled [yet].
    $SIG{TSTP} = "IGNORE";

    $$HashSep       ||= qr':';
    $ENV{EDITOR}    ||= 'ed';

    require User::pwent;
    my $pw = User::pwent::getpwnam($ENV{LOGNAME})
        or die "No username specified";

    $ENV{LOGNAME}   = $pw->name;
    $ENV{UID}       = $pw->uid;
    $ENV{HOME}      = $pw->dir;

    $TermState = POSIX::Termios->new(); 
}

sub init_readline {
    # initialize the readline library
    #
    $Term = Term::ReadLine->new($ENV{SHELL});

    $ENV{TPSH_READLINE} = $Term->ReadLine();

    #my $attr = $Term->Attribs();
    #my $feat = $Term->Features();
    #$Dumper->dumpValue($attr);
    #$Dumper->dumpValue($feat);


    #
    # stupid side-steps for various Term::ReadLine::Packages 
    #
    # some packages (Zoid) have problems with Features, others (Perl, Gnu) have
    # issues with respecting Attribs; so just trap this in an eval.
    #

    # Term off autohistory, so we can manage it ourself.
    #
    $Term->MinLine(undef);

    # turn off stupid ornamentation
    #
    $Term->ornaments(0);

    # Setup custom Term::ReadLine completion function.
    # This should work for Gnu, Perl, and Zoid implementations.
    #
    eval {
        $Term->Attribs()->{completion_function} = \&do_completion;
        # $readline::rl_completion_function = 'main::do_completion';
    } or warn "Unable to setup completion function";

    if ($Options{autohistory}) {
        loadhist_bin $ENV{HISTFILE};
    }

    unless (defined $ENV{TERM}) {
        warn "UNDEFINED TERMINAL TYPE\n";
    }
}

sub init_job_control_unix {

    # These are what signals we need for job control under POSIX.
    foreach my $sig (qw(TSTP TTIN TTOU CHLD)) {
        unless (exists $SIG{$sig}) {
            warn "Job control disabled because SIG$sig was not found";
            goto disable;
        }
    }

    my $fd = fileno(STDIN);
    my $pgid;

    # spin until we reach the foreground
    while (POSIX::tcgetpgrp($fd) != ($pgid = getpgrp(0))) {
        kill TTIN => -$pgid;
    }

    # ignore signals relevant to job control
    $SIG{$_} = "IGNORE" foreach qw(INT QUIT TSTP TTIN TTOU );

    # this will be redone by give_term() but we do it here for error control.
    unless (POSIX::setpgid($$, $pgid)) {
        warn "Job control was disabled because creating our own process group failed";
        goto disable;
    }

    # Create a job for ourself:
    my $me = make_job($$, $pgid, $fd, 'tpsh', @ARGV);
    warn "Thou shalt have no jobs before me: \$me->jid = ", $me->jid, " but must be 0!"
         if $me->jid > 0;
    $Last_Job = $me;

    give_term_unix($me) == $me->pgid
        or warn "Problem taking control of terminal for job control";


    return;

    disable: {
        $Options{monitor} = 0;
        return;
    }
}

sub init_job_control_windows {
    warn "Job control is not supported on Windows :-(yet)\n";

    $Options{monitor} = 0;
    return;
}

=pod

do_getopt ARRAYREF, HASHREF
do_getopt ARRAYREF, HASHREF, ARRAYREF

do_getopt is a wrapper around the Getopt::Long perl module; it has the same
return value as the modules GetOptions() function.  The first argument is
expected to be a reference to an array value, corresponding to the ARGument
Vector to be parsed; it will be modified as expected. The second argument is a
reference to a hash containing the arguments for Getopt::Long::GetOptions.  The
third argument is assumed to be a reference to an array, which will be passed
to Getopt::Long::Configure(); if omiited, sane default values will be used.

Normal usage:   do_getopt(\@argv, $opts);
Advanced usage: do_getopt(\@argv, $opts, $conf);

=cut

sub do_getopt {

    my ($argv, $opthash, $optconf) = @_;

    unless (!defined $optconf) {
        @$optconf = ('gnu_getopt', 'getopt_compat');
    }

    # this is a bandaid for systems with an older Getopt::Long module
    # OpenBSD 4.5 Release for example. Comparing with floats are not
    # precise, but for this it should be accurate enough.
    #
    my $ver = $Getopt::Long::VERSION_STRING ? $Getopt::Long::VERSION_STRING
                                            : "$Getopt::Long::VERSION";

	Getopt::Long::Configure(@$optconf);

    if ($ver lt '2.29') {
        # We've got to draw the line somewhere 
        # XXX don't use warn, it may not be overridden yet
        #
        print STDERR "Getopt::Long version $ver is just to old... bye\n";
        sleep 10; die "Please update your Getopt::Long\n";
    } elsif ($ver lt '2.36') {
        # before 2.36, Getopt::Long can only use ARGV
        # so we save / restore it before switching it with our own
        # array reference; to mimic 2.36's GetOptionsFromArray
        #
        my @oldargv = @ARGV;
        @ARGV = @$argv;
        my $ret = GetOptions(%$opthash);
        @$argv = @ARGV;
        @ARGV = @oldargv;
        return $ret;
    } else {
        return Getopt::Long::GetOptionsFromArray($argv, %$opthash);
    }
}

=pod

main_loop()

This is basically the core Read, Eval, Print, Loop. 
Keep it nice and tight, most things belong in subroutines.

=cut

sub main_loop {
    while (defined(my $cmdln = handle_prompt())) {
        next unless $cmdln;
        next if $cmdln =~ /^\s*#/;
        execute($cmdln);
    }
}

sub execute {
    
    $Last_Cmd = join(' ', @_);

    #
    # generate an executor subroutine for the command line
    #
    my $exe = tpsh_cgen(sh_eval @_);
    unless ($@) {
        $exe->();
        #$Dumper->dumpValues($exe);
    } else {
        warn("syntax error in the above program: code generator angry!");
        if ($Options{debug}) { warn $@ }
    }
}

=pod

handle_prompt()

return a line of input from the user or a script; may return any value that
Term::ReadLine::readline or CORE::readline.

This function will automatically handle updating history, displaying traces,
etc where appropriate. See also sh_eval() and source_bin().

=cut

sub handle_prompt {
    my $ln;

    if ($Options{interactive} && $Options{stdin}) {
        $ln = $Term->readline($ENV{PS1});
        if (defined $ln and $ln =~ /\S/) {
            $HistoryNumber ++;
            add_history($ln);
        }
    } elsif (!$Options{interactive} and $Options{cmdstr}) {
        $ln = $Options{cmdstr};
    } else {
        $ln = <$ScriptHandle>;
    }
    if (defined $ln) {
        if ((!$Options{cmdstr} and !$Options{stdin} and !$Options{interactive}))
        {
            # ^ reading from script.
            chomp($ln);
        }

        if ($Options{verbose}) {
            print $ln;
            $Options{interactive} ? print "\n" : 0;
        }
        if ($Options{xtrace}) {
            # temporary side-step for killin' error messages when PS4 is bad
            my $ps4 = $ENV{PS4} || '';
            print STDERR "${ps4}$ln\n";
        }
    }

    return $ln;
}

sub tpsh_parse {
    return () unless @_;

    my $line  = shift;
    my @stack;

    foreach my $word (expand_quotes($line)) {
        my @buf = split /([^\\]+?)([;\&\|])(.*)/, $word;
        if ($#buf) {
            push @stack, grep !/^$/, @buf;
        } else {
            push @stack, $word;
        }
    }

    @Last_Line = @stack;
    return @stack;
}

=pod

tpsh_lex LIST

Takes a list of tokens: like:

    (
        'if', 'lsx', ';',
        'then', 'echo', 'fail', ';',
        'else', 'echo', 'pass',
        ';', 'fi'
    )

And returns a list containing a command queue: like:

    (
        [ 'if', 'lsx' ],
        [ 'then', 'echo', 'fail' ],
        [ 'else', 'echo', 'pass' ],
        [ 'fi' ]
    )

I.e. it takes the output of tpsh_parse() and builds a data structure that
tpsh_cgen() understands.

=cut

sub tpsh_lex {
    return () unless @_;

    my $strbuf;
    my @words = @_;
    my @queue;
    my $buf = [];

    for (my $i=0; $i <= $#words; ++$i) {
        my $w = $words[$i];
        my $last = $i == $#words;

        if ($last or $w ne ';') {
            push @$buf, $w;
        }
        if ($last or $w eq ';') {
            push @queue, $buf;
            $buf = [];
        }
    }

    return @queue;
}

=pod

tpsh_cgen LIST

Return a coderef that will execute the specified shell command line when called.
LIST is meant to be in the format of the return value of sh_eval().

=cut

sub tpsh_cgen {
    return eval "sub {\n\n}\n" unless @_;

    # if called like: 
    #
    #     tpsh_cgen(sh_eval('if ls -l /foo; then echo yes; else echo no;fi'));
    #
    # @data = @_ = something like: (
    #  [ 'if', 'ls', '-l', '/foo'  ],
    #  ['then', 'echo', 'yes'      ],
    #  ['else', 'echo', 'no'       ],
    #  ['fi',                      ],
    #
    # if called like:
    #
    #     tpsh_cgen(sh_eval('ls -l /foo; head -1 /x'));
    #
    # @data = @_ = something like: (
    #  [ 'ls', '-l', '/foo'  ],
    #  [ 'head', '-1', '/x'  ],
    # )
    #
    # You get the idea.
    #
    my @data = @_;
    # just execute command for return value 
    my $default = sub { 'resolve_cmd("'.join('", "', @_).'")'; };
    # name of env var if we're inside a for loops do/done.
    my $for_loop_var = undef;
    # for generating code to report syntax errors in our input.
    my $error = undef;
    # generate corrisponding perl code :)
    my %targets = (
        if => sub { 'if( '.$default->(@_)." == 0 )"; },
        then => sub {
            if ($for_loop_var) {
                $error = "syntax error near unexpected token `then' where `do' was expected.";
                return '';
            }

            ' { '.$default->(@_).';'
        },
        elif => sub { ' } elsif( '.$default->(@_)." == 0 )"; },
        else => sub { ' } else { '.$default->(@_).';' },
        fi => sub { ' }' },
        # synonyms for other stuff 
        do => sub {
            my $s = ' { '.$default->(@_).';';

            if ($for_loop_var) {
                $s = ' { $ENV{'.$for_loop_var.'}=$_; '.$default->(@_).';';
                $for_loop_var = undef;
            }

            $s;
        },
        done => sub { ' }' },
        end => sub { ' }' },
        # experimental stuff
        while => sub { 'while ( '.$default->(@_)." == 0 )"; },
        until => sub { 'until ( '.$default->(@_)." == 0 )"; },
        for => sub {
            print "for()-> |", join('|, ', @_), "|\n";
            my $var = shift; # loop variable
            my @words;

            if (defined($_[0]) and $_[0] eq 'in') {
                shift; # drop the 'in'
                @words = @_;
            } elsif (defined($ENV{'@'})) {
                @words = ifsplit($ENV{'@'});
            }

            $for_loop_var=$var;
            'for ( ("'.join('", "', @words).'") )';
        },
        continue => sub { ' next;'; },
        next => sub { ' next;'; },
        break => sub { ' last;'; },
        last => sub { ' last;'; },
    );

    my $strb;
    foreach my $cmdln (@data) {
        last if defined $error;

        my $cmd = shift @$cmdln;
        my @args = @$cmdln;
        print "cmd = '$cmd'\ncmds = ('", join("', '", @args), "')\n"
                if $Options{debug};

        if (exists $targets{$cmd}) {
            $strb .= $targets{$cmd}->(@args);
        } else {
            $strb .= "\n" . $default->($cmd, @args) . ';';
        }
    }

    if (defined $error) {
        # then just report it as an error
        return sub { warn $error; };
    }

    if ($Options{debug}) {
        warn "eval('sub { ".$strb." }')";
    }
    return eval "sub { ".$strb." }";
}

=pod

resolve_cmd SCALAR
resolve_cmd LIST

resolve and execute command. If only a single scalar expression is given; split it into fields... list blah blah.

=cut

sub resolve_cmd {

    local $!;
    my @argv  = $#_ ? @_ : ifsplit @_;
    my $cmd   = $argv[0];
    my $cmdln = join ' ', @argv;
    my $op    = $argv[-2];

    # skip the I/O tricks when command is the macro built-in
    goto builtin if $cmd =~ /^macro$/;

    # I/O redirection
    #
    # command   >    write stdout to file
    # command   >>   append stdout to file
    # command   <    read stdout from file
    #
    # Note: >> must come before > in order for append mode to work.
    #
    redirect: {
        if (defined $op and $op =~ /^(>>|>|<)$/) {
            my ($ch, $op, $file) = (undef, $1, $argv[-1]);
            $cmd                 = join ' ', @argv[0..$#argv-2];
            if ($Options{noclobber}) {
                if ( $op eq '>' and -e $file) {
                    warn "'$file' already exists",
                    " and `set -o noclobber` is in effect";
                    return 1;
                }
            }
            open my $fp, $op, $file or return binerr "Can't open $file: $!";

            if ($op eq '<') {
                open $ch, '|-', $cmd;
                while (<$fp>) {
                    print $ch $_;
                }
            } else { # > or >>
                open $ch, '-|', $cmd;
                while (<$ch>) {
                    print $fp $_;
                }
                close $ch; close $fp;
            }
            return 1;
        }
    }


    # built in command
    #
    builtin: {
        my $rv = is_builtin($cmd) ?  $Builtins{$cmd}->(@argv[1..$#argv])
        :  exec_job(@argv);
        update_env '?', $rv;
        return $rv;
    }
}

=pod

exec_job LIST

Executes LIST with job control enabled.

Never returns if successful (see perldoc -f exec).
Returns a $? like value if failure, suitable for use with exit in a child process.

=cut

sub exec_job {
    
    save_term_state;
    my $pid  = fork();

    unless(defined $pid) {
        warn "Unable to fork for pexec(): $!";
        return 2;
    }

    if ($pid) {
        my $fd = fileno(STDIN);
        my $job = make_job $pid, $pid, $fd, @_;

        wait_for_job $job;
        give_term($$, getpgrp());

        restore_term_state;

        return $? >> 8;
    } else {
        $SIG{$_} = "IGNORE" foreach qw(TSTP TTIN TTOU);
        $SIG{$_} = "DEFAULT" foreach qw(TSTP CHLD);

        give_term($$, $$);
        # print "child: \$\$=$$ pid=$pid pgrp=", getpgrp(), "\n";
        exit pexec @_;
    }
}

sub wait_for_job_unix {
    my $job = shift;

    if ($job->pid == $$) {
        warn "I'm not waiting on myself!";
        return 512; # >> 8 = 2
    }

    #### UNIX SPECIFIC ####
    # we do it this way, so that we will be notified (return from waitpid) when
    # our child suspends (SIGTSTP) or exits (SIGCHLD), whatever. Regular wait()
    # can't do that.
    {
        no strict 'subs';
        #local $?; # don't clobber value: it's used by exec stuff.
        waitpid $job->pid, POSIX::WUNTRACED;

        # Update status.
        #
        # fg_bin and other code handles setting status 'Running'.
        #
        my $s = defined(${^CHILD_ERROR_NATIVE}) ? ${^CHILD_ERROR_NATIVE}
                                                : $?; # XXX Perl < v5.8.9
        if (POSIX::WIFSTOPPED($s)) {
            $job->state('Stopped');
            $Last_Job = $job;
            print_job $job;
        } elsif (POSIX::WIFEXITED($s)) {
            $job->state('Exited');
            delete $Jobs{$job->jid};
        } elsif (POSIX::WIFSIGNALED($s)) {
            $job->state('Exited with signal '.POSIX::WTERMSIG($s));
        }
    }
    #### UNIX SPECIFIC ####

}

sub wait_for_job_windows {
}

=pod

give_term JOB
give_term PID, PGID[, FD]

Gives control of the terminal associated with FD to PID/PGID. If not supplied,
the file descriptor for STDIN will be used. A Job object may also be used.

Returns the controlling PGID.

=cut

sub give_term_unix {
    return -1 unless $Options{monitor};

    my ($pid, $pgid, $fd) = $#_ == 0 ? ($_[0]->pid, $_[0]->pgid,$_[0]->fd)
                                     : @_;
    $fd = fileno(STDIN) unless $fd;

    warn $! if POSIX::setpgid($pid, $pgid) != 0;
    warn $! if POSIX::tcsetpgrp($fd, $pgid) != 0;

    return POSIX::tcgetpgrp($fd);
}

sub give_term_windows {
}

=pod

exec_cmd LIST

Executes it's arguments in a child process and waits.

exec_cmd() overrides Perl's PATH look up for exec(), by using a qualified path for
the shells %Path. exec'ing stuff this way respects the users HASHSEP, and
ensures that the operation will also respect the users pathext setting.

If job control is supported on the current platform, the job may be
suspended/continued as usual.

returns $?>>8.
returns undef if unable to fork a child process for exec().

=cut

sub exec_cmd {
    my $erv = 512; # >> 8 == 2

    if ($Options{monitor}) { # job control is on
        #### UNIX SPECIFIC ####
        if (POSIX::setpgid($$, $$) == -1) {
            warn "child $$ can't change it's process group: $!";
            return $erv;
        }
        if (POSIX::tcsetpgrp(fileno(STDIN), $$) == -1) {
            warn "child $$ can't take control of terminal: $!";
            warn "expect bad things to happen...";
            return $erv;
        }
        # reset job control signals.
        $SIG{$_} = "DEFAULT" foreach qw(INT QUIT TSTP TTIN TTOU CHLD);
        #### UNIX SPECIFIC ####
    }
    return $erv;

    if (!defined pexec @_) {
        return 32512; # >> 8 == 127; command not found
    } else {
       warn "exec_job->pexec: $!";
       return $! << 8;
    }
}

=pod 

pexec LIST

Wrapper for the built in exec function that overrides Perl's PATH look up, by
using a qualified path for the shells %Path.  exec'ing stuff this way respects
the users HASHSEP, and ensures that the operation will also respect the users
pathext setting.

never returns if successful (perldoc -f exec).
returns undef if command was not found.
returns $! if exec failed.

=cut

sub pexec {
    my    @cmds = @_;
    my    $c    = \$cmds[0];   # save typing

    my $e = $$c;
    unless ($$c = search_path $$c) {
        warn "command not found: $e";
        return 127;
    }
    exec { $cmds[0] } @cmds;
    # FIXME /file.ext not exec'able
    warn "NOT REACHED -- CHILD ON ", __FILE__, ':', __LINE__, " error: ", $!;
    return $!;
}

=pod

search_path EXPR

Attempt to find EXPR in %Path or the users PATH, and return a valid path name
for use by pexec() or comparable value. If EXPR can not be found return false.
The order of precedence is searching the %Path hash table, then the users PATH.
If the pathext option has been set, and the command has still not be found:
then repeat the search using the users PATHEXT variable.

=cut

sub search_path {

    my $cmd = $_[0];

    # this is not portable, but works most places
    if (substr($cmd, 0, 1) =~ /[.\/\\]/) {
        return $cmd;
    }

    # try to avoid unneccessary PATHEXT checks
    #
    if (exists $Path{$cmd}) {
        return $Path{$cmd};
    } else {
        for my $p (hsplit $ENV{PATH}) {
            my $fpath = File::Spec->catfile($p, $cmd);
            if (-x $fpath) {
                return $fpath;
            }
        }
    }

    if ($Options{pathext} && exists $ENV{PATHEXT}) {
        #
        # attempt a check for file extensions via PATHEXT.
        # first via cached %Path, then the users PATH.
        #
        my $pe = $ENV{PATHEXT};
        return unless defined $pe;

        for my $ext (hsplit $ENV{PATHEXT}) {
            my $p = $cmd.$ext;
            if (exists $Path{$p}) {
                return $Path{$p};
            }
        }

        for my $p (hsplit $ENV{PATH}) {
            for my $ext (hsplit $ENV{PATHEXT}) {
                my $fpath = File::Spec->catfile($p, $cmd.$ext);
                if (-x $fpath) {
                    return $fpath;
                }
            }
        }
    }

    # we didn't find anything :-(
    return;
}

=pod

rehash

Rebuild the internal %Path cache using the users PATH envrionment variable.
This subroutine is meant to be called in void context.

=cut

sub rehash {
    return unless defined $ENV{PATH};

    for my $dir (reverse hsplit $ENV{PATH}) {
        print "hashing '$dir'\n" if $Options{verbose};
        my $dh;
        if (not opendir $dh, $dir ) {
            warn "Unable to access '$dir'; skipping in \$PATH\n"
                if $Options{debug};
            next;
        }
        for my $prog (readdir $dh) {
            $Path{$prog} = "${dir}/${prog}";
        }
    }
}

=pod

do_completion TEXT_BEFORE_CURSOR, LINE, OFFSET

Called whenever insertion is attempted.

It must return a list of completions in the form
"$TEXT_BEFORE_CURSOR$COMPLETION_TEXT", other wise the Term::ReadLine
implementation may ignore the elements or break. An example: trying to complete
/, if a return value doesn't start with /, then the Perl and Zoid
implementations will overwrite the line and the Gnu implementation ignores the
element.

This means even if we need to expand ~ to complete ~/foo, all return values
must begin with ~/foo, or bad things may happen.  Term::ReadLine::.* is
something I hate.

=cut

sub do_completion {
    my ($word, $str, $start) = @_;
    my @c = ();

    $word = '' unless defined $word;
    $str  = '' unless defined $str;

    # print "\n\n\tword=$word; str=$str; start=$start\n\n";

    if ($start > 0 and !$word) {
        # completions like 'cd <tab>'
        push @c, complete_filename($word);
    }

    if ($word =~ /^[\.~]?\/*/) {
        # completions like '/u<tab>' or '.<tab>'
        push @c, complete_filename($word);
    }
    if (($word and $str =~  /^\s*$word/) or
        ($word and $str =~ /[;\|]\s*$word(?:\s*[\w;\|])?/))
    {
        # completions like 'l<tab>' or 'ls | h<tab>'
        push @c, complete_command($word);
    }

    if ($str =~ /\$\w+/) {
        # completions like '$H<tab>'
        push @c, complete_variable($word);
    }

    return @c;
}

=pod

set_completion_append_char CHAR

At the next successful completion, append CHAR to the completion. If CHAR is undef, disable this behaviour.

=cut

sub set_completion_append_char {
    my $c = shift;

    warn "'$c' is to long for a set_completion_append_char()" if length($c) > 1;

    # Gnu
    eval {
        $Term->Attribs()->{completion_append_character} = $c;
    };
    # Perl
    eval {
        no warnings 'once';
        $readline::rl_completer_terminator_character = $c;
    };
    #  No other implementations supporting completion, seem to have any control
    #  for this behaviour.
    # 
    # - Gnu allows one char.
    # - Perl allows a whole string.
    # - Zoid has no documented support for it AFAIK
    #
}

=pod

complete_filename EXPR

Evaluate EXPR as a partial filename to complete, and return the result as a
LIST. Both realitive and absolute filenames may be completed.

=cut

sub complete_filename {
    # print("\ncomplete_filename( ", join(', ', @_), ")\n");

    # don't append anything after a successful filename completion: it can be gross!
    #
    set_completion_append_char '';

    my $word = expand_parameters(expand_tilde(shift));
    #
    # File::Basename will pop a cork if the $word is bad; so use eval{} here.
    # Likewise expand_glob() / bsd_glob() can cause some heartache; so use
    # the old expand_tilde() function built into tpsh for this.
    #
    my ($basename, $dirname);
    eval { 
        $basename = basename($word);
        $dirname  = dirname($word);
    }; if ($@) {
        # should never be reached...
        warn "\n complete_filename() can't discover basename or dirname for '$word'\n";
        return ();
    }

    return map {
        if (-d $_) {
            $_ .= '/';
        }
        $_;
    } <$word*>;
}

=pod

complete_command EXPR

Returna LIST of possible Macro, Built-in, or known External Command completions
for the word EXPR. To restrict completion to macros or built-in commands, use
the complete_macro(EXPR) or complete_builtin(EXPR) subroutines.

=cut

sub complete_command {
    my $word = shift;
    # print "complete_command('$word') called\n";
    return grep /^${word}.*/, (keys %Macros, keys %Builtins, keys %Path);
}

sub complete_macro {
    my $word = shift;
    grep /^${word}.*/, (keys %Macros);
}

sub complete_variable {
    my $word = shift;
    grep /^${word}.*/, (keys %ENV);
}

sub complete_builtin {
    my $word = shift;
    grep /^${word}.*/, (keys %Builtins);
}

sub expand_quotes {

    my $ln          = join ' ', @_;
    my @tokens      = ();   # parsed tokens to return
    # 
    # delegate the expansion to here by quote or 'def'ault result.
    #
    my %quotes  = ("'" => sub { my $data = shift;
                                push @tokens, quotemeta $data;
                   },
                   '"' => sub { my $data = shift;
                                #
                                # need to recurse for stuff like `` and to
                                # mark_paramaeters after so that we handle
                                # echo "$FOO `echo $BAR`" correctly.
                                #
                                $data    = mark_parameters(join(' ', expand_quotes($data)));
                                push @tokens, $data;
                   },
                   '`' => sub { my $data = shift;
                                $data    = mark_backticks(join(' ', expand_quotes($data)));
                                push @tokens, $data;
                   },
                   'def' => sub { my $data = shift;
                                  push @tokens, ifsplit mark_parameters(
                                      scalar expand_aliases(
                                          expand_glob($data)));
                   },
       );

    # I can read this perfectly fine, maybe some can't so here's better
    # example of the expression -- Terry.
    #
    #                unqu    start quote      isqu   end quote   mayqu
    unless ($ln =~ /(.*?) (?<!\\) ([\'\"\`]) (.*?)  (?<!\\)(\2) (.*) /x) {
        #
        # just feed back the expanded fields if no quotes
        #
        $quotes{def}->($ln);
        return @tokens;
    } else {
        #
        # example 
        #
        # echo -'--hi bye--'- 2
        #    $1-$2--$3--$4-$5
        #
        # 1 and 5 are not quoted with the same quote
        # 2 and 4 are the current quotes
        # 3 is the content between them (e.g. $2$3$2)
        # the content of 5 may or may not contain external quotes.
        #
        #
        # use 'qu' as slang for 'quote[ed]' here.
        my $qu      = $2;
        my $unqu    = $1;
        my $isqu    = $3;
        my $mayqu   = $5;
        print "expand_quotes $qu: $unqu | $isqu | $mayqu\n"
            if $Options{debug};


        $quotes{def}->($unqu) if $unqu !~ /^\s*$/;

        exists $quotes{$qu} ?  $quotes{$qu}->($isqu)
                            :  $quotes{def}->($isqu);

        push @tokens, grep !/^\s*$/, expand_quotes $mayqu;

        return @tokens;
    }
}

=pod

expand_tilde EXPR

Expand all unescaped '~' symbols found in EXPR, and return the resulting
scalar. Note that this subroutine does not understand any form of quoting
except the single backslash. It is technically obsolete, but may still be
useful. If you need to evaluate expressions with more complex quoting (e.g. ',
", and `), you should use sh_eval() or play with expand_quotes() directly.

=cut

sub expand_tilde {

    my $ln = wantarray ? join ' ', @_ : shift;

    while ($ln =~ m%(?<!\\)~%) {
        $ln =~ s%~%$ENV{HOME}%;
    }
    return $ln;
}

# expand environment variables
sub expand_parameters {

    my $ln = shift;
    # print "expand_parameters(ln=|$ln|)\n";

    # XXX todo: use a global symbol table or a function to check between 
    # %ENV and %VARS or something like that
    #
    while ($ln =~ /(?<!\\)\$([@#\$\*\?\w]\w*)/) {
        my $var = $1;
        my $qvar = quotemeta $var;

        # print "var='$var' ENV{$var}='", $ENV{$var}, "' qvar='$qvar' ln='$ln'\n";

        if (exists $ENV{$var}) {
            $ln =~ s/\$$qvar/$ENV{$var}/;
        } else {
            $ln =~ s/\$$qvar//;
        }
    }

    return $ln;
}

sub mark_parameters {

    my $ln = shift;

    # XXX
    #       the [\\'] part relies on $target's quoteing of $var in the loop
    #       also this makes the assumption that this will get interpolated into ""
    #
    while ($ln =~ /(?<![\\'])\$([@#\$\*\?\w]\w*)/) {
        my $var = $1;
        my $target = '@{[expand_parameters('."'\$$var'".')]}';
        # print "target='$target' var='$var' ln='$ln'\n";

        # set this here so expanding specials like $? can work without trigging
        # an infinit loop. But also lets us keep the above as is.
        $var = quotemeta $var;

        $ln =~ s/\$$var/$target/;
    }
    return $ln;
}

sub expand_backticks {

    my $ln = shift;

    # cheating: $ln is sent to /bin/sh. We can do a I/O stream switch a roo and
    # run it ourself though.
    open my $cmd, '-|', $ln or warn $!;
    my $buf;
    $buf .= $_ while readline $cmd;
    close $cmd;

    chomp $buf if $buf;
    $buf = '' unless $buf;

    return $buf;

}

sub mark_backticks {

    my $ln = shift;

    # XXX
    #       the \" part in these quotes makes the assumption that this will get interpolated into ""
    #
    return '@{[expand_backticks(\"'.$ln.'\")]}';
}

sub expand_aliases {

    my @argv = @_;
    unless (is_macro $argv[0]) {
        return wantarray ? @argv : join ' ', @argv;
    }
    my @nargv;
    my $exp;
    my %cache;

    local %ENV       = %ENV;
    @ENV{0..$#argv}  = @argv;
    $argv[0]         = $Macros{$argv[0]};
    @nargv           = (ifsplit($argv[0]),@argv[1..$#argv]);

    # try splitting the macro expansion, and resubjecting it to
    # continued macro expansions until we reach a finite expansion, 
    # or encounter an unresolvable macro (it's done or circular). 
    #
    # In the chain x -> y -> z -> x; x resolves to back to x.
    #
    # notes:
    #
    #   the %cache stores expansions in reverse order, i.e. 
    #
    #                   y => x, x => z, z => y
    #   not
    #                   x => y, z => x, y => z
    #
    #   macros may expand to commands with spaces, so the expansions
    #   must under go the (cmd, args, ...) treatment with ifsplit.
    #
    #   Each expansion must have access to it's own local()ized set
    #   of positional parameters. XXX params not yet implemented
    #
    while (1) {
        last unless is_macro $nargv[0];

        # to save typing
        my $a    = \$nargv[0];
        my $p    = $nargv[0];

        # re-local the positional parameters
        #
        local %ENV        = %ENV;
        @ENV{0..$#nargv}  = @nargv;

        $$a     = $Macros{$$a};
        @nargv  = (ifsplit(shift @nargv), @nargv);
        $cache{(ifsplit($$a))[0]} = $p;

        # XXX remember the cache stores macro names in reverse order !!!
        #
        grep {
            if (exists $cache{$_} && $cache{$_} eq $nargv[0]) {
               $nargv[0] = $cache{$nargv[0]};
               last;
            }
        } keys %cache;

    }

    return wantarray ? @nargv : join ' ', @nargv;
}

=pod

expand_glob LIST

Performs Input Field spliting on elements of LIST, and returns the LIST with
all glob chacters expanded: IAW the shells 'noglob' option, and the users
TPSH_GLOB_FLAGS variable. It is an error for no matches to be found, or for a
perl syntax error in TPSH_GLOB_FLAGS. On error, a suitable warn()ing is fired
off, and return undef.

=cut

sub expand_glob {

    return @_ if $Options{noglob};

    my $flags = eval "$ENV{TPSH_GLOB_FLAGS}";
    if ($@) {
        warn "syntax error in \$TPSH_GLOB_FLAGS: $!";
        return undef;
    }
                    # ignore if \ escaped, ' quoted, or used as a var like $*.
    my $globch = qr/(?<![\\'\$])[\[\]\{\}?*]/;
    my @argv;

    for (ifsplit @_) {
        my @args = bsd_glob $_, $flags;
        if (!@args and /$globch/) {
                warn "no matches found: $_\n";
                return undef;
        }
        push @argv, @args ? @args : $_;
    }

    return @argv
}

sub exec_pipe {
    # e.g.   ls     |    head 
    my     ($lhs    ,   $rhs)     = @_;
    my     ($lcmd   ,   $rcmd,    $cmd);

    # sanity check the commands, delegating reporting
    # any error to our caller.
    #
    for my $side (($lhs, $rhs)) {
        my @arg = ifsplit $side; $cmd = shift @arg;
        next if -x $cmd;
        goto notfound unless defined $Path{$cmd} and -x $Path{$cmd};
    }

    # XXX we must trap SIGPIPE or things like 
    #     goodcmd | badcmd can kill tpsh!
    #
    local $SIG{PIPE} = sub { warn "$lhs | ${rhs}: $!"
                                if $Options{reportpipe}
                           };
    pipe my ($lfd, $rfd) or goto fail;

    unless (my $kid = fork) {
        defined $kid or goto fail;

        # child    -> print to $rfd
        close $lfd;
        open $rcmd, '-|', $lhs;
        while (my $ln = <$rcmd>) {
            print $rfd $ln;
        }
        close $rcmd;
        exit $?;
    } elsif ($kid) {
        # parant   -> read from $lfd
        local $SIG{CHLD} = sub { waitpid($kid, 0); };
        close $rfd;
        open $lcmd, '|-', $rhs;
        while (<$lfd>) {
            print $lcmd $_;
        }
        close $lfd;
        close $lcmd;
        return 1;
    }
    return 255; # NOTREACHED

    fail: do {
        warn "can't create pipeline or fork for ${cmd}: $!";
        return 255;
    };
    notfound: do {
        warn "command not found: $cmd";
        return 255;
    };
}

sub get_history {

    # cache HISTSIZE here, incase it changes during execution
    my $histsize = $ENV{HISTSIZE};
    my @lines    = ();

    # some readline packages might not supply this function, 
    # known: Zoid, Perl, and Gnu do but Stubs doesn't. so 
    # call within an eval to be sure.
    #
    @lines = eval { $Term->GetHistory() };
    if ($@) {
        # XXX maybe we should skip straight to this?
        @lines = @History;
    }

    if ( @lines > $histsize) {
        # this is far from optimized
        @lines = reverse @lines;
        $#lines -= $#lines - $histsize +1;
        @lines = reverse @lines;
    }
    return @lines;
}

sub add_history {

    push @History, @_;
    $Term->addhistory(@_);
}

sub load_history {

    eval { $Term->SetHistory(@_); };
    push @History, @_;
    $HistoryNumber += $#_;

    return 1;
}

sub save_history {
    return unless @_ and $ENV{HISTSIZE};

    my $histfile = shift;
    my $histsize = $ENV{HISTSIZE};
    my $fsize    = 0;
    my $hsize    = 0;
    my $fh       = undef;
    my @lines    = ();
    my @history  = get_history();

    open $fh, '+<', $histfile or
    open $fh, '+>', $histfile or return;

    # we must chomp off the end of line markers
    while (<$fh>) {
        chomp;
        push @lines, $_;
    }
    
    $fsize = $.;
    $hsize = $#lines + $#history +1;

    if ($hsize > $histsize) {
        # trim the file and rewrite
        for (0..$hsize-$histsize) {
            shift @lines;
        }
        seek $fh, 0, 0;
        print $fh "$_\n" foreach (@lines, @history);
    } else {
        # just append 
        print $fh "$_\n" foreach @history;
    }

    return close $fh;
}

=pod

binerr EXPR
binerr()

Display a built in error message for the last built in command. If EXPR is
given, it is used as the error message, other wise the $! special variable is
used.

=cut

sub binerr {
    print STDERR "${Last_Line[0]}: ", (@_ ? @_ : $!), "\n";
}

sub hsplit {

    # cache changed HASHSEP to a qr for performance
    # 
    if (ref $$HashSep ne 'Regexp') {
        # trap regexp syntax errors.
        eval {
            local $SIG{__WARN__} = 'IGNORE';
            local $SIG{__DIE__}  = sub {
                my $msg = join ' ', @_;
                $msg =~ s/(marked by <-- HERE in)/$1\n/;
                die $msg, "\n";
            };
            $$HashSep = qr/$$HashSep/
        };
        if ($@) {
            warn "syntax error: $@", "\nHASHSEP cleared\n";
            $$HashSep = '';
            exit 0;
        }
    }

    return split /$$HashSep/, $_ for @_;
}

sub ifsplit {

    # if the $IFS environment varable is unset, fall back on 
    # whitespace; this is not strictly bourne compatible, but
    # is desirable none the less
    #
    #my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;
    my $ifs=qr/[ \t\n]/;

    return grep !/^$/, split $ifs, join ' ', @_;
}

sub is_macro {
    my $name = shift || "";

    if (exists $Macros{$name}) {
        return defined $Macros{$name};
    }
}

sub is_builtin {
    my $cmd = shift;

    if (exists $Builtins{$cmd}) {
        return defined $Builtins{$cmd};
    }
}

sub err_handler {

    local $0 = basename $0;
    my $msg  = join( ' ', @_);

    $msg =~ s/ at (?:.*\/tpsh) line .*\n// unless $Options{debug};
    print STDERR "$0: $msg\n";
}

sub death_handler {

    local $0 = basename $0;
    my $msg  = join( ' ', @_);

    $msg =~ s/ at $0 line .*\n// unless $Options{debug};
    die "$0: ${msg}, stopping tpsh\n";
}


sub sh_eval {

    my $line   = join '', @_;
    my @data   = tpsh_lex tpsh_parse($line);

    return wantarray ? @data : join ' ', map { join ' ', @$_ } @data;
}

sub update_env {
    my ($var, $val) = @_;

    if ($var =~ /=/) {
        # IEEE Std 1003.1-2004 forbirds = in env-var names
        return warn "Bad syntax, '$var'\n"
    }

    $ENV{$var} = "$val";
    return 0;
}

sub min {
	my $min = shift;
	$min = $min < $_ ? $min : $_ foreach @_;
	return $min;
}

sub max {
	my $max = shift;
	$max = $max > $_ ? $max : $_ foreach @_;
	return $max;
}

=pod

igrep PATTERN, LIST

Evaluate PATTERN as a regular expression and return a list of indexes into
LIST, for every match in LIST.

=cut

sub igrep {
    my ($i, $re, @list) = (0, shift, @_);
    my @indexes = ();

    return unless $re;

    foreach (@list) {
        push @indexes, $i if /$re/;
        $i++;
    }

    return @indexes;
}

=pod

tempfile

Return the file handle and name of a tempory file.
If unseccessful, returns undef and may set $!.

=cut

sub tempfile {
    # my $fn = "/tmp/cmds";
    # open my $fh, '>', $fn or die $!;

    File::Temp->safe_level(File::Temp::HIGH);

    my ($fh, $fn);
    my $base = "/proc/$$/fd";

    if (-d $base) {
        # makes a tempfile and then deletes it but we can get the name back from the fd.
        $fh = File::Temp::tempfile();
        $fn = File::Spec->catfile($base, fileno($fh));
    } else {
        ($fh, $fn) = File::Temp::tempfile();
    }


    return ($fh, $fn);
}

sub make_job {

    my $j = new Job;

    # cheesy I know.
    {
        my @jobs = (sort keys %Jobs);
        # make sure we don't overrite the jid
        $j->jid($#jobs + (exists($Jobs{$#jobs+1}) ? 2 : 1));
        $Jobs{$j->jid} = $j;
    }
    $j->pid(shift);
    $j->pgid(shift);
    $j->fd(shift || fileno(STDIN));
    $j->argv(\@_);
    $j->state('created');

    return $j;
}

sub print_job {
    my $j = shift;

    print "[", $j->jid, "]";
    print "+" if $j == $Last_Job;
    print " \t ", $j->state, " \t ", join(' ', @{$j->argv}), "\n";
}

=pod

dump_job_status

Returns a hash of data to explain what waitpid() reported. Just for debugging really.

=cut

sub dump_job_status {
    my $s = defined(${^CHILD_ERROR_NATIVE}) ? ${^CHILD_ERROR_NATIVE}
                                            : $?; # XXX Perl < v5.8.9

    my %tests = (
        WIFEXITED   => POSIX::WIFEXITED($s),
        WEXITSTATUS => POSIX::WEXITSTATUS($s),
        WIFSIGNALED => POSIX::WIFSIGNALED($s),
        WTERMSIG    => POSIX::WTERMSIG($s),
        WIFSTOPPED  => POSIX::WIFSTOPPED($s),
        WSTOPSIG    => POSIX::WSTOPSIG($s),
    );
    return %tests;
}

=pod

get_job EXPR

Gets the associated Job for EXPR. Which is the usual convention for unix
shells. Namely %n where n is the job identification number (jid). If n is %
(e.g. EXPR = '%%') then the $Last_Job is used.

=cut

sub get_job {
    return undef  unless $Options{monitor};

    my $spec = shift;
    my $jid = substr($spec, 1, length($spec));
    return $jid =~ /^%$/ ? $Last_Job : $Jobs{$jid};
}

sub save_term_state_unix {
    if ($Options{monitor}) {
        $TermState->getattr($Jobs{0}->fd);
    }
}

sub save_term_state_windows {
}

sub restore_term_state_unix {
    if ($Options{monitor}) {
        $TermState->setattr($Jobs{0}->fd, &POSIX::TCSADRAIN);
    }
}

sub restore_term_state_windows {
}


=pod

alias_bin
alias_bin EXPR
alias_bin LIST

XXX this pod needs to be updated

When given a scalar expression, it will be split on '=' and create an alias for
the left hand side, to the right hand side: this supports the Bourne Shell
style of 'alias command=value'. When given a list, it will inspect a C-Shell
style alias, in the form of 'alias command value'. If no argument list is specified, all known aliases are displayed.

=cut
sub alias_bin {
    return macros_bin unless @_;

    my @argv = @_;
    my ($lvalue, $rvalue);

    if (grep /\w=/, @argv) {
        # split Bourne style into C-Shell for easier assignment
        ($lvalue, $rvalue) = split /=/, join(' ', @argv), 2;
    } else {
        # join C-Shell style rhs into a scalar for assignment
        ($lvalue, $rvalue) = (shift @argv, join ' ', @argv);
    }

    # maybe called like alias macroname
    if (!$rvalue) {
        return 1 if (!is_macro($lvalue));
        print "'$lvalue' => '$Macros{$lvalue}'\n" if !$rvalue;
    }


    $Macros{$lvalue} = $rvalue;
    return 0;
}

sub bg_bin {
    return binerr "job control is disabled" unless $Options{monitor};

    my $jid = shift;

    # unless (exists $Jobs{$jid}) {
        # binerr "no such job: $jid";
        # return 127;
    # }

   # if (kill(CONT => -$Jobs{$jid}->{PGID}) < 1) {
       # binerr "error signaling job $jid";
   # }
}

sub builtin_bin {
    my $bin = shift;

    if (is_builtin $bin) {
        $Builtins{$bin}->(@_);
    } else {
        binerr "not found: $bin";
        return 127;
    }
}

=pod

cd_bin
cd_bin PATH

When no argument is given, use perls 'chdir()' behavor to mimic bournes 'cd'.
Other wise attempt to change directory to PATH. If the environment variable
$CDPATH is set, search $CDPATH before giving up.

=cut

sub cd_bin {
    my $target = shift;
    my $rv     = 0;

    $target    ? ($rv = chdir $target)
               : ($rv = chdir);

    unless ($rv) {
        if (defined $ENV{CDPATH}) {
            for my $d (hsplit $ENV{CDPATH}) {
                my $dest = "${d}/$target";
                if ($target !~ /^[\/.]/) {
                    $rv = chdir $dest and last;
                }
            }
        }
    }

    binerr $! unless $rv;
    $ENV{OLDPWD} = $ENV{PWD} || "";
    $ENV{PWD}    = cwd();

    return $rv ? 0 : 2; # dash returns 2 on cd /notreal
}

sub cls_bin {

    # assume unix environment
    #
    eval { 
        require Term::Cap;
        my $tcap = Tgetent Term::Cap { TERM => undef };

        # 'cl' is the control char to clear the screen
        $tcap->Trequire('cl');
        $tcap->Tputs('cl', 1, *STDOUT);
    };

    if ($@) {
        # assume Term::Cap croaked
        my $LINES = $ENV{LINES} ? $ENV{LINES} : 75;
        for (my $n=0; $n < $LINES; $n++) {
            print "\r\n";
        }
    }

    return 0;
}

sub dirs_bin {

    my $i = 0;
    for my $dir (ifsplit $ENV{DIRSTACK}) {    
        printf "%d\t%s\n", $i, $dir;
        $i += 1;
    }

    return 0;
}

sub echo_bin {

    my $i;
    my @words = @_;

    for ($i=0; $i < scalar @words; $i++) {
        print $i < $#words ? "$words[$i] " : $words[$i];
    }

    # Not sure if I this is retroactively a bug or a feature.
    return $i + print "\n";
}

# needs more testing
sub eval_bin {

    my $args = join ' ', @_;
    return eval {
        resolve_cmd scalar sh_eval $args or binerr "syntax error: $args";
    };
}

sub exec_bin {
    my ($prog, @argv) = @_;

    exec { $prog } ($prog, @argv) or binerr;
    # bet most of you forget this trick :P
    return ($! << 0);
}

sub exit_bin {
    my $ev = shift;

    defined $ev ? exit $ev : exit $? >> 8;
    return 127;
}

sub export_bin {

    return 1;
}

sub false_bin {
    return 1;
}

sub fc_bin {

    my ($e,$l,$n,$r) = (0,0,0,0);
    my @argv = @_;
    my $opts = {'e|editor=s'    => \$e,
                'l|list'        => \$l,
                'n'             => \$n,
                'r|reverse'     => \$r,
       };
    do_getopt(\@argv, $opts);

    # only default to line numbers if listing
    $n = 1 unless $l;

    my @hist = get_history();
    # for easy testing ;)
    # my @hist = ("echo '\$HOME .*'", 'ls foo', 'ls -lt /', 'ls -l /tmp', 'echo $HOME', join(' ', @_));

    # drop this fc -l command so that it isn't captured.
    pop @hist;

    my $howmany = 10;
    my ($i, $bounds);
    my ($first, $last) = @argv;


    # if unspecified, we display the last $howmany elements
    #
    $first = max(0, ($#hist+1) - $howmany )   unless $first;

    # make sure we're setup
    #
    if ($first =~ /^\d+/) {
        # fc with numeric indexes.

        $last = min($first + $howmany, $#hist+1) unless $last;
        ($i, $bounds) = ($first, $last);

    } else {
        # then we're dealing with regex indexes.

        $i = (igrep(qr/$first/, @hist))[0];
        $bounds = (igrep(qr/$last/, @hist))[-1];
    }

    # format stuff in memory, so that we can handle our options easier.
    #
    my @out = ();
    for (; $i <= $bounds && $i <= $#hist; ++$i) {
        push @out, ($n ? ($l ? "\t" : "") : "$i\t").$hist[$i]."\n";
    }
    @out = reverse @out if $r;

    if ($l) {
        print $_ foreach @out;
    } else {
        # let's fudge them commands!
        #
        $e = $ENV{FCEDIT} || $ENV{EDITOR}           unless $e;
        binerr "no editor specified" and return 127   unless $e;


        my ($fh, $fn) = tempfile();
        print $fh $_ foreach @out;

        my $r = resolve_cmd $e, $fn;
        return $r if $r != 0;

        source_bin $fn;
    }

    return 0;
}

sub fg_bin {
    return binerr "job control is disabled" unless $Options{monitor};

    my $spec = shift || '%%';
    my $job = get_job $spec;

    unless (defined $job) {
        binerr(($spec ? "$spec: " : ''), 'no such job') unless defined $job;
        return 127;
    }
    

    # give terminal to process 
    POSIX::tcsetpgrp(fileno(STDIN), $job->pgid);

    # show user the job being continued.
    print join(' ', @{$job->argv}), "\n";

    # revive job
    $job->state('Running');
    if (kill(CONT => -$job->pgid) < 1) {
        binerr "error signaling job ", $job->pgid;
        # we don't know what state the job should be in.
        $job->state('Failed SIGCONT');
    }

    # block until job changes state
    wait_for_job $job;

    # retake terminal for tpsh
    POSIX::tcsetpgrp(fileno(STDIN), getpgrp());

    return 0;
}

sub function_bin {
    my ($name, $def) = (shift @_, join ' ', @_);
    unless ($name =~ s/\(\)$//) {
        binerr "syntax error: did you forget the parentheses? ";

        #return " ";
        return 2; # bash4.2.10 returns 2 for this syntax errorj  
    }
    $Macros{$name} = $def;

    return 1
}

sub hash_bin {

    if (@_) {
        if ($_[0] eq '-r') {
            %Path = ();
        } else {
            map { delete $Path{$_} or binerr "command not found: $_" } @_;
        }
    } else {
        while (my ($k, $v) = each %Path) {
            print "$k=$v\n";
        }
    }

    return 0;
}

sub history_bin {

    my $cmd = shift;
    my %cmds = ('edit'  => 'fc %s',
                'list'  => 'fc -l %s',
                'load'  => 'loadhist %s',
                'save'  => 'savehist %s',
                'help'  => undef,
    );

    $cmd = 'list' unless $cmd;

    if ( $cmd ne 'help' and exists $cmds{$cmd}) {
        my $args = join(' ', @_);
        my $c = $cmds{$cmd}; $c =~ s/%s/$args/;
        return execute $c;
    }

    print 'history [', join(' | ', sort keys %cmds), "] [options] [args]\n";
    return 1;
}

sub jobs_bin {

    foreach (sort keys %Jobs) {
        my $j = $Jobs{$_};

        # hide the tpsh job
        next if $j->jid == 0;

        print_job $j;

        # trim jobs we've waited until now to clear.
        delete $Jobs{$_} if $j->state =~ /^Exited/;
    }

    return 0;
}

sub loadhist_bin {

    return unless @_;

    my @argv  = @_;
    my @lines = ();

    for my $file (@argv) {
        open my $fh, '<', $file or binerr;
        next if $!;
        while (<$fh>) {
            chomp;
            push @lines, $_;
        }
    }
    return load_history @lines;
}

sub macro_bin {
    return macros_bin unless @_;

    # name( ... ) == good 
    my @line = @_;

    # get macro name and strip the parens
    #
    my $name = shift @line;
    # macro name(foo == bad
    if ($name =~ /\w*\([\w\(\)\{\}]/) {
        binerr "syntax error: no space after opening parentheses ";
        return 2;
    }
    $name =~ s/\(([^\s]*)$//g;
    #
    # macro name( foo) == also bad; or handle name()
    # if the above test failed for some fault of ours
    #
    my $endmk = pop @line || '';
    if ($endmk ne ')') {
        binerr "syntax error: no space before closing parentheses ";
        return 2;
    }

    #$Macros{$name} = '(' . join(' ', @line) . ')';
    $Macros{$name} = join(' ', @line);
    return 0;
}

sub macros_bin {
    $Dumper->dumpValue(\%Macros);
    return 0;
}

sub popd_bin {

    my @ds  = ifsplit $ENV{DIRSTACK};
    my $dir = shift @ds;

    $ENV{DIRSTACK} = join(' ', @ds);

    my $cd = cd_bin(expand_tilde $ds[0]);
    return $cd == 0 ? dirs_bin() : $cd;
}

sub pushd_bin {
    my $dir = shift || $ENV{PWD};
    my $ds  = $ENV{DIRSTACK};

    $ENV{DIRSTACK} = "$dir $ds";

    my $cd = cd_bin(expand_tilde $dir);
    return $cd == 0 ? dirs_bin() : $cd;
}

sub pwd_bin {
    my $arg = shift || '-L';
    goto bad if @_;

    if ($arg eq '-P') {
        print Cwd::realpath($ENV{PWD}), "\n";
    } elsif ($arg eq '-L') {
        print Cwd::getcwd(), "\n";
    } else {
        bad: {
            binerr "to many arguments";
            return 1;
        }
    }

    return 0;
}

sub read_bin {

    my ($prmpt, $time);
    my $line = "";
    my @argv = @_;
    my $opts = { 'p=s' => \$prmpt,
                 't=s' => \$time,
                 'e'   => sub { "no-op" },
       };

    do_getopt(\@argv, $opts);
    unless (@argv) {
        binerr "I can't read into thin air!";
        return 127;
    }

    if ($prmpt and -t *STDIN) {
        print $prmpt;
    }

    eval {
        # remove custom die for ease of error check/report
        local %SIG;
        $SIG{__DIE__} = sub { die @_ };
        $SIG{ALRM}    = sub { die "timed-out\n" };
        if ($time) {
            # an s, m, or h suffix causes sleep for sec, min, or hour
            #
            if ($time =~ /^(\d*)([smh])/) {
                if ($2 eq 's') {
                    $time = $1;
                } elsif ($2 eq 'm') {
                    $time = $1 * 60;
                } elsif ($2 eq 'h') {
                    $time = $1 * 3600;
                } else {
                    warn "internal error on ", __LINE__;
                    # NOTREACHED
                }
            }
            alarm $time;
        }
        chomp($line = <STDIN>);
        alarm 0 if $time;
    };
    if ($@) {
        # on time out, init the vars to empty strings
        @ENV{@argv} = ('') x scalar @argv;

        unless($@ eq "timed-out\n") {
            # if we hit here and didn't time out, something errored.
            binerr $@;
            return 1;
        }
        return 0;
    } else {
        # set each var to the words
        #
        # XXX because ifsplit has no notion of a &split 'LIMIT'
        #     if we used ifsplit here instead of a manual split,
        #       read x y
        #       foo bar ham
        #     would set $y to 'bar' instead of 'bar ham'
        #
        my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;
        @ENV{@argv} = grep !/^$/, split $ifs, $line, scalar(@argv);
        return 0;
    }
}

sub rehash_bin {
    rehash;
    return 0;
}

sub savehist_bin {

    my $histfile = shift || $ENV{HISTFILE} || "";

    return save_history $histfile;
}

sub set_bin {
    my @argv = @_;
    if (@argv) {
        do_getopt(\@argv, $Setopts);
    } else {
        # pretty print everything like sh
        foreach my $var (sort keys %ENV) {
            my $val = $ENV{$var};
            # shut up uninitialized warnings if VAR=
            #
            $val = "" unless defined $val;

            if ($val =~ /\s/) {
                $val =~ s/$_/$_/g foreach ('\n', '\t');
                $val = "'$val'";
            }
            print $var, "=", $val, "\n";
        }
        return 0;
    }
}

sub setenv_bin {
    my ($var, $val) = @_;

    # print "setenv $var='", $val, "'\n";
    return update_env($var, $val);
}

sub setvar_bin {

    return 1;
}

# this builtin doesn't follow the usual exit status convention yet and might never.
sub sleep_bin {

    my $secs = shift;

    # an s, m, or h suffix causes sleep for sec, min, or hour
    #
    if ($secs and $secs =~ /^(\d+)([smh]?)/) {
        if ($2 eq 's') {
            $secs = $1;
        } elsif ($2 eq 'm') {
            $secs = $1 * 60;
        } elsif ($2 eq 'h') {
            $secs = $1 * 3600;
        } else {
            # NOTREACHED
            unless (defined $2) {
                warn "internal error on line ", __LINE__;
            }
        }

        return sleep $secs;
    } else {
        print "usage: sleep timespec\n";
        return 0;
    }
}

sub source_bin {

    my @args = @_;
    eval {
        local $SIG{__DIE__} = sub { die @_ };
        for my $file (@args) {
            open my $fh, '<', $file     or die "${file}: $!\n";
            while (defined(my $ln = <$fh>)) {
                next if $ln =~ /^\s*#/;
                foreach (sh_eval $ln) {
                    resolve_cmd @$_ if defined @$_;
                }
            }
        }
    };

    return binerr $@ if $@;
    return 0;
}

sub test_bin {

    return 1;
}

sub times_bin {

    return 1;
}

sub trap_bin {

    return 1;
}

sub true_bin {
    return 0;
}

sub type_bin {
    my $rv = 0;

    for (@_) {
        # check macros, builtins, path, and current directory.
        #
        print "$_ is a macro for $Macros{$_}\n"   
                                    and next          if is_macro $_;
        print "$_ is a shell builtin\n" 
                                    and next          if is_builtin $_;
        if (my $p = search_path $_) {
            print "$_ is $p\n";
            next;
        }
        #
        # this is a custom exstension
        #
        print "$_ may be $ENV{PWD}/$_\n"            
                                    and next          if -x "./$_";

        print "$_ not found\n";
        # a command was not found, adjust exit status to reflect this but continue.
        $rv = 127;
    }
    return $rv;
}

sub unalias_bin {

    delete @Macros{@_};
    return 0;
}

sub unset_bin {

    return 0;
}

sub which_bin {

    # XXX all these $flag eq ... deserve an internal coderef
    my $flag  = " ";
    my $found = 0;
    my @argv  = @_;
    my @progs = ();
    my $opts  = { 'a|all'      => sub { $flag = '-a' },
                  's|sillent'  => sub { $flag = '-s' },
                  '<>'         => sub { push @progs, shift },
       };
    do_getopt(\@argv, $opts);
    #@progs = @argv;

    for (@progs) {
        # first check if built in or macro
        if (is_builtin $_) {
            print "${_}: shell built-in command\n" unless $flag eq '-s';
            $found++;
            next unless $flag eq '-a';
        }
        if (is_macro $_) {
            print "${_}: macro for $Macros{$_}\n" unless $flag eq '-s';
            $found++;
            next unless $flag eq '-a';
        }
        for my $p (hsplit $ENV{PATH}) {
            my $path = "${p}/${_}";
            if (-x $path) {
                print "$path\n" unless $flag eq '-s';
                $found++;
                last unless $flag eq '-a' or $flag eq '-s';
            }
        }
        if ($flag ne '-s') {
            print "${_}: not found\n" unless $found;
        }
    }

    if ($found >= scalar @progs) {
        $? = 0;
        return 0;
    } else {
        $? = 1 << 8;
        return 1;
    }
}

END {
    if ($Options{autohistory}) {
        savehist_bin $ENV{HISTFILE};
    }
}

#
#----------------------------------------------------------
#                begin program execution 
#----------------------------------------------------------
unless (caller) {
    do_getopt(\@ARGV, $Setopts);
    $Options{interactive} = $Options{monitor} = -t *STDIN && !@ARGV ? 1 : 0;
    $Options{stdin} = @ARGV ? 0 : 1;
    if ($Options{cmdstr}) {
        $Options{interactive} = $Options{monitor} = 0;
    }
    init_sh();
    if ($Options{cmdstr}) {
        execute  handle_prompt $Options{cmdstr};
        exit $ENV{'?'};
    }
    exit main_loop();
}
