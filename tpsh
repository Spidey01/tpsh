#!/usr/bin/env perl
#
# Terry's Portable SHell
#
#--------------------------------------------------------------------

use warnings;
use strict;

use Cwd;
use Dumpvalue;
use Getopt::Long;
use Pod::Usage;
use Term::ReadLine;


#----------------------------------------------------------
#                Subroutine Prototypes
#----------------------------------------------------------

#
# Internal subroutines
#
sub init_sh;
sub do_getop;
sub main_loop;
sub pexec;
sub resolve_cmd;
sub handle_prompt;
sub rehash;
sub update_env;
sub sh_eval;
sub expand_quotes;
sub expand_tilde;
sub expand_parameters;
sub expand_aliases;
sub exec_pipe;
sub binerr;
sub hsplit;
sub ifsplit;
sub err_handler;
sub death_handler;
#
# These subs implement built in commands
#
sub alias_bin;
sub builtin_bin;
sub cd_bin;
sub echo_bin;
sub eval_bin;
sub exit_bin;
sub export_bin;
sub hash_bin;
sub read_bin;
sub rehash_bin;
sub set_bin;
sub setenv_bin;
sub setvar_bin;
sub test_bin;
sub times_bin;
sub trap_bin;
sub type_bin;
sub unalias_bin;
sub unset_bin;

#----------------------------------------------------------
#                Global Data Structures
#----------------------------------------------------------

#
# Represents command line flags and set -options
#
my %Options = ( 
    allexport       =>  0,
    notify          =>  0,
    noclobber       =>  0,
    emacs           =>  1,
    errexit         =>  0,
    noglob          =>  0,
    ignoreeof       =>  0,
    interactive     =>  0, 
    monitor         =>  0,
    noexec          =>  0,
    physical        =>  0,  # this will be removed unless POSIX requires it
    privileged      =>  0,
    stdin           =>  0,
    vi              =>  0,
    verbose         =>  0,
    xtrace          =>  0,
);

#
# Used whenever split /sep/, "foosepbar" is needed. I.e. $PATH, $CDPATH.
# init_sh will initialize and compile this as a regular expression appropirate
# for the users operating system, i.e. ':' or ':'.
#
# You should use hsplit(LIST) instead of directly using split 
#
my $HashSep;

#
# Introspector / debugging aid -- will be initialized in init_sh()
#
my $Dumper = undef;

#
# Holds the last executed command, usually built in.
#
my $Last_Cmd = '';

#
# Holds the last parsed line of input
#
my @Last_Line = ();


#
# Reference to our ReadLine interface
#
my $Term;

#
# A hash containing a cache of all known commands, in the format
# of command => /path/to/command. Only the rehash() sub should
# ever modify this cache directly!
#
my %Path = ();

#
# A hash of the users aliases in alias => expression format.
# The aliases are kept separate from %Builtins, so the user
# can _not_ clobber builtin commands; only mask them.
#
my %Aliases = ();

#
# A hash of built in commands in the format of command => sub.
# Each handler should be named command_bin for consistency. For 
# security reasons, you should never modify this hash at runtime.
#
my %Builtins = ( '['            => sub { warn "Not implemented\n" },
                 'alias'        => \&alias_bin,
                 'bg'           => sub { warn "Not implemented\n" },
                 'bind'         => sub { warn "Not implemented\n" },
                 'builtin'      => \&builtin_bin,
                 'cd'           => \&cd_bin,
                 'chdir'        => \&cd_bin,
                 'command'      => sub { warn "Not implemented\n" }, 
                 'echo'         => \&echo_bin,
                 'eval'         => \&eval_bin,
                 'exec',        => \&exec_bin,
                 'exit'         => \&exit_bin,
                 'export'       => \&export_bin,
                 'false'        => sub { warn "Not implemented\n" },
                 'fc'           => sub { warn "Not implemented\n" },
                 'fg'           => sub { warn "Not implemented\n" },
                 'getopts'      => sub { warn "Not implemented\n" },
                 'hash'         => \&hash_bin,
                 'jobs'         => sub { warn "Not implemented\n" },
                 'local'        => sub { warn "Not implemented\n" },
                 'read'         => \&read_bin,
                 'readonly'     => sub { warn "Not implemented\n" },
                 'rehash'       => \&rehash_bin,
                 'return'       => sub { warn "Not implemented\n" }, 
                 'set'          => \&set_bin,
                 'setenv'       => \&setenv_bin,
                 'setvar'       => \&setvar_bin,
                 'shift'        => sub { warn "Not implemented\n" },
                 'test'         => \&test_bin,
                 'times'        => \&times_bin,
                 'trap'         => \&trap_bin,
                 'true'         => sub { warn "Not implemented\n" },
                 'type'         => \&type_bin,
                 'ulimit'       => sub { warn "Not implemented\n" },
                 'umask'        => sub { warn "Not implemented\n" },
                 'unalias'      => \&unalias_bin,
                 'unset'        => \&unset_bin,
                 'wait'         => sub { warn "Not implemented\n" },
);


#----------------------------------------------------------
#                Subroutine Implementations
#----------------------------------------------------------

sub init_sh {
    # handle default initializations for the environment
    # XXX this is a _huge_ ass sub

    # override warn/die behaviour with the desired output
    #
    $SIG{__WARN__} = \&err_handler;
    $SIG{__DIE__} = \&death_handler;

    if (grep { $^O eq $_ } qw(VMS MacOS NetWare beos vos)) {
        warn "$0: Unsupported OS $^O -- YMMV\n";
    }

    # if none of the accepted UNIX / NT login names are found in the
    # users environment, treat this as a massively fatal error NOW.
    do {
        my $tried = 0;
        my @names = qw( USER LOGNAME USERNAME );
        for my $try (@names) {
            $tried++ unless defined $ENV{$try};
        }
        die "$0: Unable to find your username" if $tried == @names; 
    };

    my ($isWin, $isUnix, %pw);
    if (grep { $^O eq $_ } qw(MSWin32 os2 dos)) {
        ($isWin, $isUnix) = (1, 0);
        require Win32API::Net;
        Win32API::Net::UserGetInfo('', $ENV{USERNAME}, 3, my $href={}) || die $!;
        %pw = ( name => $href->{name}, 
                homedir => $href->{homeDir} || $ENV{USERPROFILE},
                uid => $href->{userId} );
        $ENV{LOGNAME} = $pw{name};
    } else {
        ($isUnix, $isWin) = (1, 0);
        require User::pwent;
        my $pw = User::pwent::getpwnam($ENV{LOGNAME}) 
            or die "No username specified";
        %pw = ( name => $pw->name, homedir => $pw->dir, uid => $pw->uid, );
    }


    # XXX test this on Windows
    $Dumper = new Dumpvalue;

    # These are defaults for our own internal variables
    #
    unless ($ENV{EDITOR}) {
        if ($isUnix) {
            $ENV{EDITOR} = '/bin/ed';
        } elsif ($isWin) {
            $ENV{EDITOR} = 'edit';
        }
    }
    $ENV{FCEDIT}    ||= $ENV{EDITOR};
    $ENV{HISTSIZE}  ||= 512;
    $ENV{IFS}       ||= " \t\n";
    $ENV{PS1}       ||= $pw{uid} != 1 ? '$ ' : '# ';
    $ENV{PS2}       ||= '> ';
    $ENV{PS4}       ||= '+ ';
    $ENV{CDPATH}    ||= "";

    # inheritied from the system, normally...
    $ENV{OSTYPE}    ||= $^O;
    $ENV{SHELL}     ||= $0;             #  don't use $pw to get shell.
    $ENV{HOME}      ||= $pw{homedir};
    $ENV{USER}      ||= $pw{name};
    $ENV{USERNAME}  ||= $pw{name};

    # We consider LOGNAME to be the authoritve form of the users name as
    # specified in our starting environment. This should never fail, but I'm to
    # sleepy to think clearly... so figure it out later.
    #
    if ($ENV{LOGNAME} ne $pw{name}) {
        die 'The $USER, $LOGNAME, and $USERNAME variables must match!';
    }

    $ENV{MAIL}      ||= "/var/mail/${ENV{USER}}";
    #$ENV{MAILPATH}  ||= 'unused';

    unless (defined $ENV{PATH}) {
        $ENV{PATH} = $isUnix ? "/usr/bin:/bin" 
                             : "C:/Windows/system32;C:/Windows;" .
                               "C:/Windows/System32/WBem;";
    }

    if ($isUnix) {
        $HashSep = qr':';
    } else {
        $HashSep = qr';';
    }

    rehash();

    $ENV{'$'} = $$;
    unless (defined $ENV{TERM}) {
        warn "UNDEFINED TERMINAL TYPE\n";
    }

    # initialize the readline library
    #
    $Term = Term::ReadLine->new($ENV{SHELL});
    $ENV{TPSH_READLINE} = $Term->ReadLine();

    # change to the users home directory by default.
    # this will also take care of the OLDPWD/PWD variables.
    #
    $Builtins{chdir}->($ENV{HOME});
}

sub do_getopt {
	Getopt::Long::Configure('gnu_getopt', 'auto_version', 'auto_help');
	GetOptions(
               'a|allexport'    =>  \$Options{allexport},
               'b|notify'       =>  \$Options{notify},
               'C|noclobber'    =>  \$Options{noclobber},
               'E|emacs'        =>  \$Options{emacs},
               'e|errexit'      =>  \$Options{errexit},
               'f|noglob'       =>  \$Options{noglob},
               'I|ignoreeof'    =>  \$Options{ignoreeof},
               'i|interactive'  =>  \$Options{interactive},
               'm|monitor'      =>  \$Options{monitor},
               'P|physical'     =>  \$Options{physical},
               'p|privileged'   =>  \$Options{privileged},
               's|stdin'        =>  \$Options{stdin},
               'V|vi'           =>  \$Options{vi},
               'v|verbose'      =>  \$Options{verbose},
               'x|xtrace'       =>  \$Options{xtrace},
               #---
               #'h'              =>   \&pod2usage(-verbose => 0, -exitval => 1),
               #'help'           =>   \&pod2usage(-verbose => 1, -exitval => 1),
               #'m|man'          =>   \&pod2usage(-verbose => 3, -exitval => 0),
              );
}

=pod

main_loop()

Program main loop

=cut
sub main_loop {
    while (defined(my $cmdln = handle_prompt())) {
        my @argv;
        if ($cmdln =~ /([\'\"\`])/) {
            @argv = expand_quotes($1, $cmdln)
        } else {
            @argv = sh_eval($cmdln);
        }
        next unless @argv;

        resolve_cmd(@argv);
    }
}

sub handle_prompt {
    my $ln = "";

    $ln = $Term->readline($ENV{PS1});
    $Term->addhistory($ln) 
        if defined $ln and $ln =~ /\S/;

    return $ln;
}

sub resolve_cmd {
    local $!;
    my ($cmd, @buf)   = (ifsplit shift @_);
    my @argv;  push @argv, @buf, @_;
    my $cmdln = join ' ', $cmd, @argv;
    $Last_Cmd = $cmdln;


    # test if it's a pipe
    #
    if ($cmdln =~ /([^|]*) \| ([^|]*)/) {
        return exec_pipe $1, $2 || warn "bad pipe: $!\n";
    }

    # I/O redirection
    #
    # command   >    write stdout to file
    # command   >>   append stdout to file
    # command   <    read stdout from file
    #
    # Note: >> must come before > in order for append mode to work.
    #
    if ($cmdln =~ /([^><]*) \s* (>>|>|<) \s* (.*)/x) {
        return warn "Bad syntax: $cmdln"
            unless defined $1 and defined $2 and defined $3;
        my ($ch, $commd, $op, $file) = (undef, $1, $2, $3);

        open my $fp, $op, $file or return binerr "Can't open $file: $!";
        if ($op eq '<') {
            open $ch, '|-', $commd;
            while (<$fp>) {
                print $ch $_;
            }
        } else {
            open $ch, '-|', $commd;
            if ( $op eq '>' and -x $file) {
                # the noclobber option is not implemented yet, so always warn
                print STDERR "File already exists, overwriting it\n";
            }
            while (<$ch>) {
                print $fp $_;
            }
            close $ch; close $fp; 
        }
        return 1;
    }


    # built in command
    #
    defined $Builtins{$cmd} ?  return $Builtins{$cmd}->(@argv)
                            :  return pexec($cmd, @argv);
}

=pod 

pexec LIST

Executes it's arguments in a child process and waits.

=cut
sub pexec {
    my @cmds = @_;
    local $!;
    my $pid = fork();
    die "Unable to fork for pexec(\@): $!" 
        unless defined $pid;

    if ($pid) {
        wait();
    } else {
        if (defined $cmds[0]) {
            exec { $cmds[0] } @cmds or warn "$cmds[0] command not found";
            exit $?;
        }
        exit 0; # then there wasn't any command given.
    }
}

sub rehash {
    for my $dir (reverse hsplit $ENV{PATH}) {
        print "hashing $dir\n";
        opendir my $dh, $dir 
            or warn "Unable to access $dir; skipping in \$PATH\n";
        for my $prog (readdir $dh) {
            $Path{$prog} = "${dir}/${prog}";
        }
    }
}

sub expand_quotes {

    my ($quote, $cmdln)     = @_;
    my ($start, $mid, $end) = (0, 1, 2);

    # these subs do the actual expansion work, and will be passed the string
    # found within the quotes as it's sole arugment.
    #
    my %evals = ('"' => sub {
                       chomp (my $s = sh_eval(@_));
                       return $s;
                 },
                 "'" => sub {
                       return join ' ', @_;
                 },
                 '`' => sub {
                       open my $cmd, '-|', @_ or warn $!;
                       my $buf;
                       $buf .= $_ while readline $cmd;
                       close $cmd;
                       return $buf;
                 }
    );

    #
    # The stack will be returned as an argument vector, containing
    # the expanded elements of "command line"
    #
    my @stack;

    #
    # $push->(0, sh_eval it)
    # $push->(1, expand the quotes)
    #
    # pushes data onto the stack after expansion.
    # Don't push onto @stack outside this helper.
    #
    my $push = sub {

        my ($wanteval, @data) = @_;

        if ($wanteval) {
            push @stack, $evals{$quote}->(@data);
        } else {
            push @stack, ifsplit sh_eval(@data);
        }
    };

    #
    # offsets into @argv will be equal to:
    #
    # start:     null or words
    # middle:    quoted words
    # end:       null or words
    #
    # Only the '$mid' offset will ever contain the quoted words. 
    # the others contain unquoted words before or after the quoted ones, or are
    # null values ('' or undef).
    #
    my @argv = split /$quote/, $cmdln, 3;


    #
    # process the argument vector, pushing onto return stack
    #

    if (defined $argv[$start]) {
        # words before any quotes
        $push->(0, $argv[$start]);
    }

    if (defined $argv[$mid]) { 
        # expand the quotes

        if (exists $evals{$quote}) {
            print "expansion: ";
            print $quote, $evals{"$quote"}->($argv[$mid]), $quote, "\n";
            $push->(1, $argv[$mid]);
        } else {
            print "no expansion";
            warn "this line should never be reached!";
            $push->(0, $argv[$mid]);
        }
    }

    if (defined $argv[$end] and $argv[$end] ne '') {
        # there are words after the quotes
        $push->(0, $argv[$end]);
    }

    # make sure no null elements have been pushed, other wise
    # things like tpsh> ls "foo bar" ham spam eggs will not work
    #
    return grep { $_ !~ /^$/ } @stack;
}

# handle tilde expansions
sub expand_tilde {

    my $ln = wantarray ? join ' ', @_ : shift;

    while ($ln =~ m%~%) {
        unless ($ln =~ m%\\~%) {
            $ln =~ s%~%$ENV{HOME}%;
        }
    }
    return $ln;
}

# expand environment variables
sub expand_parameters {

    my $ln = shift;

    # XXX todo: use a global symbol table or a function to check between 
    # %ENV and %VARS or something like that
    #
    while ($ln =~ /\$(\w*)\b.*/) {
        my $var = $1;
        if (exists $ENV{$var}) {
            $ln =~ s/\$$var/$ENV{$var}/;
        } else {
            $ln =~ s/\$$var//;
        }
    }

    return $ln;
}

# expand aliases
sub expand_aliases {

    my @argv = @_;

    for my $arg (@argv) {
        if (defined $Aliases{$arg}) {
            $arg = $Aliases{$arg};
        }
    }

    return wantarray ? @argv : join ' ', @argv;
}

sub exec_pipe {
    # e.g.   ls     |    head 
    my     ($lhs    ,   $rhs)     = @_;
    my     ($lcmd   ,   $rcmd,    $cmd);

    # sanity check the commands, delegating reporting
    # any error to our caller.
    #
    for my $side (($lhs, $rhs)) {
        my @arg = ifsplit $side; $cmd = shift @arg;
        next if -x $cmd;
        goto notfound unless defined $Path{$cmd} and -x $Path{$cmd};
    }

    pipe my ($lfd, $rfd) or goto fail;

    unless (my $kid = fork) {
        defined $kid or goto fail;

        # child    -> print to $rfd
        close $lfd;
        open $rcmd, '-|', $lhs;
        while (my $ln = <$rcmd>) {
            print $rfd $ln;
        }
        close $rcmd;
        exit $?;
    } elsif ($kid) {
        # parant   -> read from $lfd
        local $SIG{CHLD} = sub { waitpid($kid, 0); };
        close $rfd;
        open $lcmd, '|-', $rhs;
        while (<$lfd>) {
            print $lcmd $_;
        }
        close $lfd;
        close $lcmd;
        return 1;
    }
    return 255; # NOTREACHED

    fail: do {
        warn "can't create pipeline or fork for ${cmd}: $!";
        return 255;
    };
    notfound: do {
        warn "command not found: $cmd";
        return 255;
    };
}

=pod

binerr EXPR
binerr()

Display a built in error message for the last built in command. If EXPR is
given, it is used as the error message, other wise the $! special variable is
used.

=cut

sub binerr {
    print STDERR "${Last_Cmd}: ", @_ ? shift : $!;
}

sub hsplit {
    return split /$HashSep/, $_ for @_;
}

sub ifsplit {

    # if the $IFS environment varable is unset, fall back on 
    # whitespace; this is not strictly bourne compatible, but
    # is desirable none the less
    #
    my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;

    return grep !/^$/, split $ifs, join ' ', @_;
}


sub err_handler {

    my $msg = join( ' ', @_);

    $msg =~ s/ at $0 line .*\n//;
    print STDERR "$0: $msg\n";
}

sub death_handler {

    my $msg = join( ' ', @_);

    $msg =~ s/ at $0 line .*\n//;
    die "$0: ${msg}, stopping tpsh\n";
}


sub sh_eval { 
    # XXX none of this understands the shells quoting rules

    my $ln   = join ' ', map { $Options{noglob} ? $_ : glob $_ } @_;
    my @argv = ifsplit $ln;

    # dirty fix: turn off alias expansions for unalias
    #
    if ($ln !~ m/(unalias [^;|><]*)/) { 
        $ln = expand_aliases(@argv);
    }
                     
    $ln = expand_parameters($ln);
    $ln = expand_tilde($ln);

    return wantarray ? ifsplit $ln  : $ln;
}

sub update_env {
    my ($var, $val) = @_;
    $val = sh_eval($val);

    return warn "$0: Bad syntax, '$var'\n" 
        if $var =~ /=/; # IEEE Std 1003.1-2004 forbirds = in env-var names

    $ENV{$var} = "$val";
}


=pod

alias_bin
alias_bin EXPR
alias_bin LIST

When given a scalar expression, it will be split on '=' and create an alias for
the left hand side, to the right hand side: this supports the Bourne Shell
style of 'alias command=value'. When given a list, it will inspect a C-Shell
style alias, in the form of 'alias command value'. If no argument list is specified, all known aliases are displayed.

=cut
sub alias_bin {
    unless (@_) {
        $Dumper->dumpValue(\%Aliases);
        return;
    }
    my @argv = @_;
    my ($lvalue, $rvalue);

    if (grep /=/, @argv) {
        # split Bourne style into C-Shell for easier assignment
        ($lvalue, $rvalue) = split /=/, join(' ', @argv), 2;
    } else {
        # join C-Shell style rhs into a scalar for assignment
        ($lvalue, $rvalue) = (shift @argv, join ' ', @argv);
    }

    $Aliases{$lvalue} = $rvalue;
    return 1;
}

sub builtin_bin {
    my $bin = shift;

    if (exists $Builtins{$bin}) {
        $Builtins{$bin}->(@_) 
    } else {
        warn "not found";
    }
}

=pod

cd_bin
cd_bin PATH

When no argument is given, use perls 'chdir()' behavor to mimic bournes 'cd'.
Other wise attempt to change directory to PATH. If the environment variable
$CDPATH is set, search $CDPATH before giving up.

=cut

sub cd_bin {
    my $target = shift;
    my $rv     = 0;

    $target    ? ($rv = chdir $target)
               : ($rv = chdir);

    unless ($rv) {
        if (defined $ENV{CDPATH}) {
            for my $d (hsplit $ENV{CDPATH}) {
                $rv = chdir "${d}/$target" and last;
            }
        }
    }

    warn $! unless $rv;
    $ENV{OLDPWD} = $ENV{PWD};
    $ENV{PWD}    = cwd();
    return $rv;
}

sub echo_bin {

    print map { "$_ " } @_;
    print "\n";
}

sub eval_bin {

}

sub exec_bin {
    my ($prog, @argv) = @_;

    exec { $prog } ($prog, @argv) or warn $!;
}

sub exit_bin {
    my $ev = shift;

    defined $ev ? exit $ev : exit 0;
}

sub export_bin {
    
}

sub hash_bin {

    while (my ($k, $v) = each %Path) {
        print "$k=$v\n";
    }

    return 1;
}

sub read_bin {

}

sub rehash_bin {
    rehash;
}

sub set_bin {
    my @argv = @_;

    if (@argv) {
       warn "set [opts] [args] is not implemented yet\n";
    } else {
        # pretty print everything like sh
        while (my ($var, $val) = each %ENV) {
            if ($val =~ /\s/) {
                $val = "'$val'";
            }
            print $var, "=", $val, "\n";
        }
        return 1;
    }
}

sub setenv_bin {
    my ($var, $val) = @_;

    update_env($var, $val);
}

sub setvar_bin {

}

sub test_bin {

}

sub times_bin {

}

sub trap_bin {

}

sub type_bin {

    for (@_) {
        # check aliases, builtins, path, current directory.
        print "$_ is an alias for $Aliases{$_}\n"   if defined $Aliases{$_};
        # XXX functions are not implemented yet
        print "$_ is a shell builtin\n"             if defined $Builtins{$_};
        print "$_ is $Path{$_}\n"                   if defined $Path{$_};
        #
        # this is a custom exstension
        #
        print "$_ may be $ENV{PWD}/$_\n"            if -x "./$_";
    }
    return 1;
}

sub unalias_bin {

    delete @Aliases{@_};
}

sub unset_bin {

}


#
#----------------------------------------------------------
#                begin program execution 
#----------------------------------------------------------
if (__PACKAGE__ eq 'main') {
    init_sh();
    do_getopt();
    exit main_loop();
}
