#!/usr/bin/env perl
#
# Terry's Portable SHell
#
#--------------------------------------------------------------------

use warnings;
use strict;


use Cwd;
use Dumpvalue;
use File::Basename;
use File::Glob          ':glob';
use File::Spec;
use File::Temp;
use FindBin;
use Getopt::Long;       # do NOT export GetOptionsFrom*
use Term::ReadLine;

#
# override $0 for the entire script
#
FindBin::again(); 
local $0 = File::Spec->catfile($FindBin::Bin, $FindBin::Script);

#----------------------------------------------------------
#                Subroutine Prototypes
#----------------------------------------------------------

#
# Internal subroutines
#
sub init_sh;
sub init_win32;
sub init_unix;
sub init_readline;
sub do_getop;
sub main_loop;
sub tpsh_parse;
sub tpsh_lex;
sub tpsh_cgen;
sub argv_rejoin;
sub resolve_cmd;
sub pexec;
sub search_path;
sub handle_prompt;
sub rehash;
sub update_env;
sub sh_eval;
sub do_completion;
sub complete_filename;
sub complete_command;
sub complete_macro;
sub complete_builtin;
sub expand_quotes;
sub expand_tilde;
sub expand_parameters;
sub expand_aliases;
sub expand_glob;
sub exec_pipe;
sub get_history;
sub add_history;
sub load_history;
sub save_history;
sub binerr;
sub hsplit;
sub ifsplit;
sub is_macro;
sub is_builtin;
sub err_handler;
sub death_handler;
#
# These subs implement built in commands
#
sub alias_bin;
sub builtin_bin;
sub cd_bin;
sub cls_bin;
sub dirs_bin;
sub echo_bin;
sub eval_bin;
sub exit_bin;
sub export_bin;
sub false_bin;
sub fc_bin;
sub function_bin;
sub hash_bin;
sub history_bin;
sub loadhist_bin;
sub macro_bin;
sub macros_bin;
sub popd_bin;
sub pushd_bin;
sub pwd_bin;
sub read_bin;
sub rehash_bin;
sub savehist;
sub set_bin;
sub setenv_bin;
sub setvar_bin;
sub sleep_bin;
sub source_bin;
sub test_bin;
sub times_bin;
sub trap_bin;
sub true_bin;
sub type_bin;
sub unalias_bin;
sub unset_bin;
sub which_bin;

#----------------------------------------------------------
#                Global Data Structures
#----------------------------------------------------------

#
# Represents command line flags and set -options
#
my %Options = (
    allexport       =>  0,
    autohistory     =>  0,
    notify          =>  0,
    noclobber       =>  0,
    debug           =>  0,
    emacs           =>  1,
    errexit         =>  0,
    noglob          =>  0,
    ignoreeof       =>  0,
    interactive     =>  0,
    monitor         =>  0,
    noexec          =>  0,
    privileged      =>  0,
    pathext         =>  1,
    reportpipe      =>  0,
    stdin           =>  0,
    vi              =>  0,
    verbose         =>  0,
    xtrace          =>  0,
    #
    # This next option is used for things like tpsh -c "str"; do not document 
    # this as a set -/+o option
    # because it should never be used that way!
    #
    cmdstr          =>  '',
);

#
# Hashref for updating %Options through Getopt::Long / do_getopt()
#
my $Setopts = {
    'a|allexport'    =>  \$Options{allexport},
    'A|autohistory'  =>  \$Options{autohistory},
    'b|notify'       =>  \$Options{notify},
    'c=s'            =>  \$Options{cmdstr},
    'C|noclobber'    =>  \$Options{noclobber},
    'D|debug'        =>  \$Options{debug},
    'E|emacs'        =>  \$Options{emacs},
    'e|errexit'      =>  \$Options{errexit},
    'f|noglob'       =>  \$Options{noglob},
    'I|ignoreeof'    =>  \$Options{ignoreeof},
    'i|interactive'  =>  \$Options{interactive},
    'm|monitor'      =>  \$Options{monitor},
    'o=s'            =>  sub {
                             my @opts = keys %Options;
                             for my $o (split /,/, $_[1]) {
                                 grep /$o/, @opts or
                                    die("no such option: $o"), last;
                                 $Options{$o} = 1;
                             }
                         },
    'p|privileged'   =>  \$Options{privileged},
    'reportpipe'     =>  \$Options{reportpipe},
    's|stdin'        =>  \$Options{stdin},
    'V|vi'           =>  \$Options{vi},
    'v|verbose'      =>  \$Options{verbose},
    'x|xtrace'       =>  \$Options{xtrace},
    #---
    #'h'              =>   \&pod2usage(-verbose => 0, -exitval => 1),
    #'help'           =>   \&pod2usage(-verbose => 1, -exitval => 1),
    #'m|man'          =>   \&pod2usage(-verbose => 3, -exitval => 0),
};


#
# Used whenever split /sep/, "foosepbar" is needed. I.e. $PATH, $CDPATH.
# init_sh will initialize and compile this as a regular expression appropirate
# for the users operating system, i.e. ':' or ':'.
#
# You should use hsplit(LIST) instead of directly using this with split 
#
my $HashSep = \$ENV{HASHSEP};

#
# Introspector / debugging aid.
#
my $Dumper = new Dumpvalue;

#
# Holds the last executed command, usually built in.
#
my $Last_Cmd = '';

#
# Holds the last parsed line of input
#
my @Last_Line = ();

#
# Internal history buffer, holds individual command lines sans the '\n'.
# This is used if the ReadLine module doesn't support history. You should
# never access this directly, use the main::*_history() functions here.
# note: generally this is here so things like fc still work with when
# Term::ReadLine::Stubs is the only readline module available.
#
my @History = ();

#
# In an interactive shell, this holds the number of command lines that have
# been entered by the user. If you call get_history() to get a list of lines
# within HISTSIZE, you can find your numerical indexs starting point within 
# the global history as $#get_history() - $HistoryNumber. 
#
my $HistoryNumber = 1;

#
# Set to a truth value if Term::ReadLine can automatically add history
# to its internal buffers when getting a line. Other wise, we need to
# do our own emulation.
#
our $ReadLineSupportsHistory = 0;


#
# Reference to our ReadLine interface
#
my $Term;

#
# A hash containing a cache of all known commands, in the format
# of command => /path/to/command. Only the rehash() sub should
# ever modify this cache directly!
#
my %Path = ();

#
# A hash of the users macros in macro => expression format.
# The macros are kept separate from %Builtins, so the user
# can _not_ clobber builtin commands; only mask them.
#
my %Macros = ();

#
# A hash of built in commands in the format of command => sub.
# Each handler should be named command_bin for consistency. For 
# security reasons, you should never modify this hash at runtime.
#
my %Builtins = ( '.'            => \&source_bin,
                 '['            => sub { warn "Not implemented\n" },
                 'alias'        => \&alias_bin,
                 'bg'           => sub { warn "Not implemented\n" },
                 'bindkey'      => sub { warn "Not implemented\n" },
                 'builtin'      => \&builtin_bin,
                 'cd'           => \&cd_bin,
                 'chdir'        => \&cd_bin,
                 'cls'          => \&cls_bin,
                 'command'      => sub { warn "Not implemented\n" },
                 'dirs'         => \&dirs_bin,
                 'echo'         => \&echo_bin,
                 'eval'         => \&eval_bin,
                 'exec',        => \&exec_bin,
                 'exit'         => \&exit_bin,
                 'export'       => \&export_bin,
                 'false'        => \&false_bin,
                 'fc'           => \&fc_bin,
                 'fg'           => sub { warn "Not implemented\n" },
                 'function'     => \&function_bin,
                 'getopts'      => sub { warn "Not implemented\n" },
                 'hash'         => \&hash_bin,
                 'history'      =>\ &history_bin,
                 'jobs'         => sub { warn "Not implemented\n" },
                 'loadhist'     => \&loadhist_bin,
                 'local'        => sub { warn "Not implemented\n" },
                 'macro'        => \&macro_bin,
                 'macros'       => \&macros_bin,
                 'popd'         => \&popd_bin,
                 'pushd'        => \&pushd_bin,
                 'pwd'          => \&pwd_bin,
                 'read'         => \&read_bin,
                 'readonly'     => sub { warn "Not implemented\n" },
                 'rehash'       => \&rehash_bin,
                 'return'       => sub { warn "Not implemented\n" },
                 'savehist'     => \&savehist_bin,
                 'set'          => \&set_bin,
                 'setenv'       => \&setenv_bin,
                 'setvar'       => \&setvar_bin,
                 'shift'        => sub { warn "Not implemented\n" },
                 'sleep'        => \&sleep_bin,
                 'source'       => \&source_bin,
                 'test'         => \&test_bin,
                 'times'        => \&times_bin,
                 'trap'         => \&trap_bin,
                 'true'         => \&true_bin,
                 'type'         => \&type_bin,
                 'ulimit'       => sub { warn "Not implemented\n" },
                 'umask'        => sub { warn "Not implemented\n" },
                 'unalias'      => \&unalias_bin,
                 'unset'        => \&unset_bin,
                 'wait'         => sub { warn "Not implemented\n" },
                 'which'        => \&which_bin,
);

#----------------------------------------------------------
#                Subroutine Implementations
#----------------------------------------------------------

sub init_sh {
    # Get the shell up and running.
    #   -> this is one _huge_ ass sub

    # override warn/die behaviour with the desired output
    #
    $SIG{__WARN__} = \&err_handler;
    $SIG{__DIE__}  = \&death_handler;

    # ignore ^Z/SUSP key for now: we don't have support for job control yet.
    $SIG{TSTP} = "IGNORE";

    if (grep { $^O eq $_ } qw(VMS MacOS NetWare beos vos)) {
        warn "Unsupported OS $^O -- YMMV\n";
    }

    $ENV{OSTYPE} = $^O;

    # sets the following:
    #   $LOGNAME
    #   $UID
    #   $HOME
    #   $EDITOR
    #   $HASHSEP
    #
    {
        if (grep { $^O eq $_ } qw(MSWin32 os2 dos)) {
            init_win32();
        } else {
            init_unix();
        }

        foreach (qw(LOGNAME UID HOME)) {
            die "$_ environment variable not set" unless defined $ENV{$_};
        }
    }

    # for compatability with Windows NT and BSD UNIX
    $ENV{USERNAME} = $ENV{USER} = $ENV{LOGNAME};

    # There can only be one value!
    if (defined $ENV{TMPDIR}) {
        $ENV{TMP}   ||= $ENV{TMPDIR};
        $ENV{TEMP}  ||= $ENV{TMPDIR};
    } else {
        $ENV{TMPDIR} ||= $ENV{TMP} || $ENV{TEMP};
        $ENV{TMP}    ||= $ENV{TMPDIR};
        $ENV{TEMP}   ||= $ENV{TMPDIR};
    }

    # some programs (e.g. nvi) will pop a cork if TMPDIR=""
    # so delete them all, unless there is a value.
    unless (defined $ENV{TMPDIR}) {
        delete @ENV{qw/TMPDIR TMP TEMP/};
    }

    #
    # O.K. now on to shell settings.
    #
    $ENV{HISTSIZE}  ||= 512;
    $ENV{IFS}       ||= " \t\n";
    $ENV{PS1}       ||= $ENV{UID} != 1 ? '$ ' : '# ';
    $ENV{PS2}       ||= '> ';
    $ENV{PS4}       ||= '+ ';
    $ENV{SHELL}     ||= $0;             #  don't use $pw to get shell.

    $ENV{'$'} = $$;

    # Set defaults for shell globbing behavour
    #
    $ENV{TPSH_GLOB_FLAGS} ||= 'GLOB_QUOTE | GLOB_TILDE';

    if ($Options{interactive}) {
        # change to the users home directory by default.
        # this will also take care of the OLDPWD/PWD variables.
        #
        cd_bin $ENV{HOME};
        $ENV{DIRSTACK} = "~";
    } else {
        # scripts/commands run from CWD.
        $ENV{PWD} = $ENV{DIRSTACK} = Cwd::getcwd();
    }

    # call now, so any default $PATH is pre-hashed for the users $ENV scripts
    rehash();

    # process the users ENV files
    #
    if ($Options{interactive}) {
        if (exists $ENV{ENV}) {
            foreach (hsplit $ENV{ENV}) { 
                my $f = sh_eval $_;
                source_bin $f or warn "$f: $!";
            }
        }
    }

    init_readline();
}

sub init_win32 {
    # Does MS Windows specific initializations

    $$HashSep       ||= qr';';
    $ENV{EDITOR}    ||= 'edit';

    # ActivePerl bundles this, Strawberry doesn't. So eval it.
    my %pw;
    eval {
        require Win32API::Net;
        Win32API::Net::UserGetInfo('', $ENV{USERNAME}, 3, my $href={}) 
            || die $!;

        $ENV{LOGNAME} = $href->{name};
        $ENV{UID} = $href->{userId};
        $ENV{HOME} = $href->{homeDir} || $ENV{USERPROFILE};
    };

    return unless $@;

    # We will just have to guess... bah!

    $ENV{LOGNAME} = $ENV{USERNAME};
    $ENV{UID} = $<;
    $ENV{HOME} = $ENV{USERPROFILE};
}

sub init_unix {
    # Does UNIX specific initializations

    $$HashSep       ||= qr':';
    $ENV{EDITOR}    ||= 'ed';

    require User::pwent;
    my $pw = User::pwent::getpwnam($ENV{LOGNAME})
        or die "No username specified";

    $ENV{LOGNAME}   = $pw->name;
    $ENV{UID}       = $pw->uid;
    $ENV{HOME}      = $pw->dir;
}

sub init_readline {
    # initialize the readline library
    #
    $Term = Term::ReadLine->new($ENV{SHELL});

    $ENV{TPSH_READLINE} = $Term->ReadLine();

    my $attr = $Term->Attribs();
    my $feat = $Term->Features();

    #
    # stupid side-steps for various Term::ReadLine::Packages 
    #
    # some packages (Zoid) have problems with Features, others (Perl, Gnu) have
    # issues with respecting Attribs; so just trap this in an eval.
    #
    eval {
        if ($feat->{autohistory}) {
            $ReadLineSupportsHistory = "yes";

            # XXX ignored by Stubs and Perl
            $attr->{autohistory} = 1;
        }
    };
    if ($@ and substr($ENV{TPSH_READLINE}, 16) eq 'Zoid') {
        # band-aid for Zoid
        $attr->{autohistory} = 1;
        $ReadLineSupportsHistory = "yes";
    }
    #
    # turn off stupid ornamentation
    # XXX works in Gnu, Zoid;  !Stubs, !Perl
    #
    $attr->{ornaments} = 0;

    # Setup custom completion function
    # XXX works for Zoid, Perl, and Gnu (Zoid is best)
    #
    $attr->{completion_function}   = \&do_completion;

    if ($Options{autohistory}) {
        loadhist_bin $ENV{HISTFILE};
    }

    unless (defined $ENV{TERM}) {
        warn "UNDEFINED TERMINAL TYPE\n";
    }
}

=pod

do_getopt ARRAYREF, HASHREF
do_getopt ARRAYREF, HASHREF, ARRAYREF

do_getopt is a wrapper around the Getopt::Long perl module; it has the same
return value as the modules GetOptions() function.  The first argument is
expected to be a reference to an array value, corresponding to the ARGument
Vector to be parsed; it will be modified as expected. The second argument is a
reference to a hash containing the arguments for Getopt::Long::GetOptions.  The
third argument is assumed to be a reference to an array, which will be passed
to Getopt::Long::Configure(); if omiited, sane default values will be used.

Normal usage:   do_getopt(\@argv, $opts);
Advanced usage: do_getopt(\@argv, $opts, $conf);

=cut

sub do_getopt {

    my ($argv, $opthash, $optconf) = @_;

    unless (!defined $optconf) {
        @$optconf = ('gnu_getopt', 'getopt_compat');
    }

    # this is a bandaid for systems with an older Getopt::Long module
    # OpenBSD 4.5 Release for example. Comparing with floats are not
    # precise, but for this it should be accurate enough.
    #
    my $ver = $Getopt::Long::VERSION_STRING ? $Getopt::Long::VERSION_STRING
                                            : "$Getopt::Long::VERSION";

	Getopt::Long::Configure(@$optconf);

    if ($ver lt '2.29') {
        # We've got to draw the line somewhere 
        # XXX don't use warn, it may not be overridden yet
        #
        print STDERR "Getopt::Long version $ver is just to old... bye\n";
        sleep 10; die "Please update your Getopt::Long\n";
    } elsif ($ver lt '2.36') {
        # before 2.36, Getopt::Long can only use ARGV
        # so we save / restore it before switching it with our own
        # array reference; to mimic 2.36's GetOptionsFromArray
        #
        my @oldargv = @ARGV;
        @ARGV = @$argv;
        my $ret = GetOptions(%$opthash);
        @$argv = @ARGV;
        @ARGV = @oldargv;
        return $ret;
    } else {
        return Getopt::Long::GetOptionsFromArray($argv, %$opthash);
    }
}

=pod

main_loop()

This is basically the core Read, Eval, Print, Loop. 
Keep it nice and tight, most things belong in subroutines.

=cut

sub main_loop {
    while (defined(my $cmdln = handle_prompt())) {
        next unless $cmdln;
        next if $cmdln =~ /^\s*#/;
        #
        # generate an executor subroutine for the command line
        #
        my $exe = tpsh_cgen(sh_eval $cmdln);
        unless ($@) {
            $exe->();
            #$Dumper->dumpValues($exe);
        } else {
            warn("syntax error in the above program");
            if ($Options{debug}) { warn $@ }
        }
    }
}

=pod

handle_prompt()

return a line of input from the user or a script; may return any value that
Term::ReadLine::readline or CORE::readline.

This function will automatically handle updating history, displaying traces,
etc where appropriate. See also sh_eval() and source_bin().

=cut

sub handle_prompt {
    my $ln;

    if ($Options{interactive} && !$Options{stdin}) {
        $ln = $Term->readline($ENV{PS1});
        if (defined $ln and $ln =~ /\S/) {
            $HistoryNumber ++;
            add_history($ln);
        }
    } else {
        $ln = <>;
    }
    if (defined $ln) {
        if ($Options{verbose}) {
            print $ln;
            $Options{interactive} ? print "\n" : 0;
        }
        if ($Options{xtrace}) {
            # temporary side-step for killin' error messages when PS4 is bad
            my $ps4 = $ENV{PS4} || '';
            print STDERR "${ps4}$ln";
            $Options{interactive} ? print "\n" : 0;
        }
    }

    return $ln;
}

sub tpsh_parse {
    return () unless @_;

    my $line  = shift;
    my @stack;

    foreach my $word (expand_quotes($line)) {
        my @buf = split /([^\\]+?)([;\&\|])(.*)/, $word;
        if ($#buf) {
            push @stack, grep !/^$/, @buf;
        } else {
            push @stack, $word;
        }
    }

    return @stack;
}

sub tpsh_lex {
    return () unless @_;

    my $strbuf;
    my @words = @_;
    my @queue;

    #
    # Rejoin the tokens into a command queue of [ word lists ]. 
    #
    #   ( [cmd1, arg, list, ...], [cmd2, arg, list, ...] )
    #
    # Note that the ';', '&', and '|' symbols terminate commands but 
    # the the '&' and '|' operators must be retained in word list as 
    # a trailing word; so things like resolve_cmd() can handle the 
    # operators correctly.
    #
    for my $s (ifsplit (@words, ';')) {
        if ($s eq ';' or $s eq '|' or $s eq '&') {
            unless ($s eq ';') {
                push @$strbuf, $s;
            }
            push @queue, $strbuf;
            $strbuf = ();
        } else {
            push @$strbuf, "$s ";
        }
    }

    #
    # Reconsitute the word lists into proper argument vectors,
    # and strip out the [back]quotes where found.
    #
    #   ( [cmd1, arg list, ...], [cmd2, arg list, ...] )
    #
    return map { 
               [map { $_ =~ s/(?<!\\)\\//g;  $_ } @$_] 
           } map { 
               [argv_rejoin @$_] 
           } @queue;
}

=pod

tpsh_cgen LIST

Return a coderef that will execute the specified shell command line when called.
LIST is meant to be in the format of the return value of sh_eval().

=cut

sub tpsh_cgen {
    return eval "sub {\n\n}\n" unless @_;

    # if called like: 
    #
    #     tpsh_cgen(sh_eval('if ls -l /foo; then echo yes; else echo no;fi'));
    #
    # @data = @_ = something like: (
    #  [ 'if', 'ls', '-l', '/foo'  ],
    #  ['then', 'echo', 'yes'      ],
    #  ['else', 'echo', 'no'       ],
    #  ['fi',                      ],
    #
    # if called like:
    #
    #     tpsh_cgen(sh_eval('ls -l /foo; head -1 /x'));
    #
    # @data = @_ = something like: (
    #  [ 'ls', '-l', '/foo'  ],
    #  [ 'head', '-1', '/x'  ],
    # )
    #
    # You get the idea.
    #
    my @data = @_;
    # just execute command for return value 
    my $default = sub { "resolve_cmd(\"".join("\", \"", @_)."\")"; };
    # generate corrisponding perl code :)
    my %targets = (
        if => sub { 'if( '.$default->(@_)." == 0 )"; },
        then => sub { ' { '.$default->(@_).';' },
        elif => sub { ' } elsif( '.$default->(@_)." == 0 )"; },
        else => sub { ' } else { '.$default->(@_).';' },
        fi => sub { ' }' },
        # synonyms for other stuff 
        do => sub { ' { '.$default->(@_).';' },
        done => sub { ' }' },
        end => sub { ' }' },
        # experimental stuff
        while => sub { 'while ( '.$default->(@_)." == 0 )"; },
        until => sub { 'until ( '.$default->(@_)." == 0 )"; },
        for => sub { 'warn "Not implemented yet\n";'; },
        continue => sub { ' next;'; },
        next => sub { ' next;'; },
        break => sub { ' last;'; },
        last => sub { ' last;'; },
    );

    my $strb;
    foreach my $cmdln (@data) {
        my $cmd = shift @$cmdln;
        my @args = @$cmdln;
        print "cmd = \"$cmd\"\ncmds = (\"", join('", "', @args), "\")\n"
                if $Options{debug};

        if (exists $targets{$cmd}) {
            $strb .= $targets{$cmd}->(@args);
        } else {
            $strb .= "\n" . $default->($cmd, @args) . ';';
        }
    }

    if ($Options{debug}) {
        warn "eval('sub { $strb }')";
    }
    return eval "sub { $strb }";
}

sub argv_rejoin {

    my $strbuf = "";
    my @argv = @_;
    my @tokens;
    my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;

    for my $tok (@argv) {
        if ($tok =~ /\\$ifs$/ or $strbuf) {
            # partial argument, left join into strbuf
            chop $tok unless $tok =~ //;
            $strbuf .= $tok;
        }
        if ($tok !~ // and $strbuf) {
                # we hit end of tok's to append to strbuf
                # and therefore have the entire argument.
                push @tokens, $strbuf;
                $strbuf = "";
                next;
        }
        unless ($strbuf) {
            # a stand alone argument, e.g. echo or z in `echo "x y" z`
            chop $tok;
            push @tokens, $tok;
        }
    }
    return @tokens;
}

=pod

resolve_cmd SCALAR
resolve_cmd LIST

resolve and execute command. If only a single scalar expression is given; split it into fields... list blah blah.

=cut

sub resolve_cmd {

    local $!;
    my @argv  = $#_ ? @_ : ifsplit @_;
    my $cmd   = $argv[0];
    my $cmdln = join ' ', @argv;
    my $op    = $argv[-2];

    # skip the I/O tricks when command is the macro built-in
    goto builtin if $cmd =~ /^macro$/;

    # test if it's a pipe
    #
  pipe:
    if ($cmdln =~ /([^|]*) \| ([^|]*)/) {
        return warn "\nPipes are currently disabled, sorry!\n";
        return exec_pipe $1, $2 || warn "bad pipe: $!\n";
    }

    # I/O redirection
    #
    # command   >    write stdout to file
    # command   >>   append stdout to file
    # command   <    read stdout from file
    #
    # Note: >> must come before > in order for append mode to work.
    #
  redirect:
    if (defined $op and $op =~ /^(>>|>|<)$/) {
        my ($ch, $op, $file) = (undef, $1, $argv[-1]);
        $cmd                 = join ' ', @argv[0..$#argv-2];
        if ($Options{noclobber}) {
            if ( $op eq '>' and -e $file) {
                warn "'$file' already exists",
                     " and `set -o noclobber` is in effect";
                return 0;
            }
        }
        open my $fp, $op, $file or return binerr "Can't open $file: $!";

        if ($op eq '<') {
            open $ch, '|-', $cmd;
            while (<$fp>) {
                print $ch $_;
            }
        } else {
            open $ch, '-|', $cmd;
            while (<$ch>) {
                print $fp $_;
            }
            close $ch; close $fp;
        }
        return 1;
    }


    # built in command
    #
  builtin:
    my $rv = is_builtin($cmd) ?  $Builtins{$cmd}->(@argv[1..$#argv])
                              :  pexec(@argv);
    update_env '?', $rv;
    return $rv;
}

=pod 

pexec LIST

Executes it's arguments in a child process and waits.

pexec() overrides Perl's PATH look up for exec(), by using a qualified path for
the shells %Path. exec'ing stuff this way respects the users HASHSEP, and
ensures that the operation will also respect the users pathext setting.

returns $?>>8.

=cut

sub pexec {

    local $!;
    my    @cmds = @_;
    my    $c    = \$cmds[0];   # save typing
    my    $pid  = fork();

    die "Unable to fork for pexec(\@): $!"
        unless defined $pid;

    if ($pid) {
        wait();
        return $? >> 8;
    } else {
        my $e = $$c;
        unless ($$c = search_path $$c) {
            warn "command not found: $e";
            exit 1;
        }
        exec { $cmds[0] } @cmds;
        # FIXME /file.ext not exec'able
        warn "NOT REACHED -- CHILD ON ", __FILE__, ':', __LINE__;
        exit $? >> 8;
    }
}

=pod

search_path EXPR

Attempt to find EXPR in %Path or the users PATH, and return a valid path name
for use by pexec() or comparable value. If EXPR can not be found return false.
The order of precedence is searching the %Path hash table, then the users PATH.
If the pathext option has been set, and the command has still not be found:
then repeat the search using the users PATHEXT variable.

=cut

sub search_path {

    my $cmd = $_[0];

    # this is not portable, but works most places
    if (substr($cmd, 0, 1) =~ /[.\/\\]/) {
        return $cmd;
    }

    # try to avoid unneccessary PATHEXT checks
    #
    if (exists $Path{$cmd}) {
        return $Path{$cmd};
    } else {
        for my $p (hsplit $ENV{PATH}) {
            my $fpath = File::Spec->catfile($p, $cmd);
            if (-x $fpath) {
                return $fpath;
            }
        }
    }

    if ($Options{pathext} && exists $ENV{PATHEXT}) {
        #
        # attempt a check for file extensions via PATHEXT.
        # first via cached %Path, then the users PATH.
        #
        my $pe = $ENV{PATHEXT};
        return unless defined $pe;

        for my $ext (hsplit $ENV{PATHEXT}) {
            my $p = $cmd.$ext;
            if (exists $Path{$p}) {
                return $Path{$p};
            }
        }

        for my $p (hsplit $ENV{PATH}) {
            for my $ext (hsplit $ENV{PATHEXT}) {
                my $fpath = File::Spec->catfile($p, $cmd.$ext);
                if (-x $fpath) {
                    return $fpath;
                }
            }
        }
    }

    # we didn't find anything :-(
    return;
}

=pod

rehash

Rebuild the internal %Path cache using the users PATH envrionment variable.
This subroutine is meant to be called in void context.

=cut

sub rehash {
    return unless defined $ENV{PATH};

    for my $dir (reverse hsplit $ENV{PATH}) {
        print "hashing '$dir'\n" if $Options{verbose};
        my $dh;
        if (not opendir $dh, $dir ) {
            warn "Unable to access '$dir'; skipping in \$PATH\n"
                if $Options{debug};
            next;
        }
        for my $prog (readdir $dh) {
            $Path{$prog} = "${dir}/${prog}";
        }
    }
}

sub do_completion {
    my ($word, $str) = @_;
    my @completions  = ();

    # rules of thumb:
    #
    # if first word, do all completions; subject to special cases.
    # if not first word, do file completion
    #

    my @argv = ifsplit $str;
    my $grep = sub { grep { $argv[0] eq $_ }  @_ };
    #
    # complete all-stuff for these commands
    #
    my @all  = ('type', 'which');
    # complete macros for these commands
    #
    my @macs = ('alias', 'unalias');
    #
    # complete built-in commands for these commands
    #
    my @cmds = ('builtin');

    # allow command completion for things like 'builtin e^I'
    # and 'alias l^I', fall though to normal rules if needed
    #
    if ($grep->(@all)) {
        push @completions, complete_command($word);
    } elsif ($grep->(@macs)) {
        return complete_macro $word;
    } elsif ($grep->(@cmds)) {
        return complete_builtin $word;
    }

    # normal completion rules
    if ($word =~ /^$argv[0]/) {
        push @completions, complete_command($word);
        push @completions, complete_filename($word);
    } else {
        push @completions, complete_filename($word);
    }

    return sort @completions;
}

=pod

complete_filename EXPR

Evaluate EXPR as a partial filename to complete, and return the result as a
LIST. Both realitive and absolute filenames may be completed.

=cut

sub complete_filename {
    #
    # File::Basename will pop a cork if the $word is bad; so use eval{} here.
    # Likewise expand_glob() / bsd_glob() can cause some heartache; so use
    # the old expand_tilde() function built into tpsh for this.
    #
    my ($word, $basename, $dirname);
    eval { 
        $word     = expand_parameters(expand_tilde(shift));
        $basename = basename($word);
        $dirname  = dirname($word);
    }; if ($@) {
        # should never be reached...
        warn "\n completion error \n";
    }

    my $cwd      = $ENV{PWD};
    if ($word =~ /\/$/) {
        # make sure we complete what's in the child dir
        $basename .= "/";
    }

    # this is a cheap trick but works well for now

    cd_bin $dirname
        or warn "$! maybe $dirname was removed by another process?";

    my @a = bsd_glob "${basename}*", GLOB_MARK | GLOB_QUOTE | GLOB_TILDE;

    cd_bin $cwd
        or warn "directory overflow: $!", "maybe $cwd was removed?";

    @a = map { "${dirname}/${_}" } @a;
    return @a;
}

=pod

complete_command EXPR

Returna LIST of possible Macro, Built-in, or known External Command completions
for the word EXPR. To restrict completion to macros or built-in commands, use
the complete_macro(EXPR) or complete_builtin(EXPR) subroutines.

=cut

sub complete_command {
    my $word = shift;
    grep /^${word}.*/, (keys %Macros, keys %Builtins, keys %Path);
}

sub complete_macro {
    my $word = shift;
    grep /^${word}.*/, (keys %Macros);
}

sub complete_builtin {
    my $word = shift;
    grep /^${word}.*/, (keys %Builtins);
}

sub expand_quotes {

    my $ln          = join ' ', @_;
    my @tokens      = ();   # parsed tokens to return
    # 
    # delegate the expansion to here by quote or 'def'ault result.
    #
    my %quotes  = ("'" => sub { my $data = shift;
                                push @tokens, quotemeta $data;
                   },
                   '"' => sub { my $data = shift;
                                $data    = expand_parameters($data);
                                push @tokens, quotemeta($data);
                   },
                   '`' => sub { my $data = shift;
                                open my $cmd, '-|', $data or warn $!;
                                my $buf;
                                $buf .= $_ while readline $cmd;
                                close $cmd;
                                push @tokens, $buf;
                   },
                   'def' => sub { my $data = shift; 
                                  push @tokens, ifsplit expand_parameters(
                                      scalar expand_aliases(
                                          expand_glob($data)));
                   },
       );

    # I can read this perfectly fine, maybe some can't so here's better
    # example of the expression -- Terry.
    #
    #                unqu    start quote      isqu   end quote   mayqu
    unless ($ln =~ /(.+?) (?<!\\) ([\'\"\`]) (.*?)  (?<!\\)(\2) (.*) /x) {
        #
        # just feed back the expanded fields if no quotes
        #
        $quotes{def}->($ln);
        return @tokens;
    } else {
        #
        # example 
        #
        # echo -'--hi bye--'- 2
        #    $1-$2--$3--$4-$5
        #
        # 1 and 5 are not quoted with the same quote
        # 2 and 4 are the current quotes
        # 3 is the content between them (e.g. $2$3$2)
        # the content of 5 may or may not contain external quotes.
        #
        #
        # use 'qu' as slang for 'quote[ed]' here.
        my $qu      = $2;
        my $unqu    = $1;
        my $isqu    = $3;
        my $mayqu   = $5;
        print "expand_quotes $qu: $unqu | $isqu | $mayqu\n"
            if $Options{debug};


        $quotes{def}->($unqu) if $unqu !~ /^\s*$/;

        exists $quotes{$qu} ?  $quotes{$qu}->($isqu)
                            :  $quotes{def}->($isqu);

        push @tokens, grep !/^\s*$/, expand_quotes $mayqu;

        return @tokens;
    }
}

=pod

expand_tilde EXPR

Expand all unescaped '~' symbols found in EXPR, and return the resulting
scalar. Note that this subroutine does not understand any form of quoting
except the single backslash. It is technically obsolete, but may still be
useful. If you need to evaluate expressions with more complex quoting (e.g. ',
", and `), you should use sh_eval() or play with expand_quotes() directly.

=cut

sub expand_tilde {

    my $ln = wantarray ? join ' ', @_ : shift;

    while ($ln =~ m%(?<!\\)~%) {
        $ln =~ s%~%$ENV{HOME}%;
    }
    return $ln;
}

# expand environment variables
sub expand_parameters {

    my $ln = shift;

    # XXX todo: use a global symbol table or a function to check between 
    # %ENV and %VARS or something like that
    #
    while ($ln =~ /(?<!\\)\$(\w*)/) {
        my $var = $1;
        if (exists $ENV{$var}) {
            $ln =~ s/\$$var/$ENV{$var}/;
        } else {
            $ln =~ s/\$$var//;
        }
    }

    return $ln;
}

sub expand_aliases {

    my @argv = @_;
    unless (is_macro $argv[0]) {
        return wantarray ? @argv : join ' ', @argv;
    }
    my @nargv;
    my $exp;
    my %cache;

    local %ENV       = %ENV;
    @ENV{0..$#argv}  = @argv;
    $argv[0]         = $Macros{$argv[0]};
    @nargv           = (ifsplit($argv[0]),@argv[1..$#argv]);

    # try splitting the macro expansion, and resubjecting it to
    # continued macro expansions until we reach a finite expansion, 
    # or encounter an unresolvable macro (it's done or circular). 
    #
    # In the chain x -> y -> z -> x; x resolves to back to x.
    #
    # notes:
    #
    #   the %cache stores expansions in reverse order, i.e. 
    #
    #                   y => x, x => z, z => y
    #   not
    #                   x => y, z => x, y => z
    #
    #   macros may expand to commands with spaces, so the expansions
    #   must under go the (cmd, args, ...) treatment with ifsplit.
    #
    #   Each expansion must have access to it's own local()ized set
    #   of positional parameters. XXX params not yet implemented
    #
    while (1) {
        last unless is_macro $nargv[0];

        # to save typing
        my $a    = \$nargv[0];
        my $p    = $nargv[0];

        # re-local the positional parameters
        #
        local %ENV        = %ENV;
        @ENV{0..$#nargv}  = @nargv;

        $$a     = $Macros{$$a};
        @nargv  = (ifsplit(shift @nargv), @nargv);
        $cache{(ifsplit($$a))[0]} = $p;

        # XXX remember the cache stores macro names in reverse order !!!
        #
        grep {
            if (exists $cache{$_} && $cache{$_} eq $nargv[0]) {
               $nargv[0] = $cache{$nargv[0]};
               last;
            }
        } keys %cache;

    }

    return wantarray ? @nargv : join ' ', @nargv;
}

=pod

expand_glob LIST

Performs Input Field spliting on elements of LIST, and returns the LIST with
all glob chacters expanded: IAW the shells 'noglob' option, and the users
TPSH_GLOB_FLAGS variable. It is an error for no matches to be found, or for a
perl syntax error in TPSH_GLOB_FLAGS. On error, a suitable warn()ing is fired
off, and return undef.

=cut

sub expand_glob {

    return @_ if $Options{noglob};

    my $flags = eval "$ENV{TPSH_GLOB_FLAGS}";
    if ($@) {
        warn "syntax error in \$TPSH_GLOB_FLAGS: $!";
        return undef;
    }
    my $globch = qr/[\[\]\{\}?*]/;
    my @argv;

    for (ifsplit @_) {
        my @args = bsd_glob $_, $flags;
        if (!@args and /$globch/) {
                warn "no matches found: $_\n";
                return undef;
        }
        push @argv, @args ? @args : $_;
    }

    return @argv
}

sub exec_pipe {
    # e.g.   ls     |    head 
    my     ($lhs    ,   $rhs)     = @_;
    my     ($lcmd   ,   $rcmd,    $cmd);

    # sanity check the commands, delegating reporting
    # any error to our caller.
    #
    for my $side (($lhs, $rhs)) {
        my @arg = ifsplit $side; $cmd = shift @arg;
        next if -x $cmd;
        goto notfound unless defined $Path{$cmd} and -x $Path{$cmd};
    }

    # XXX we must trap SIGPIPE or things like 
    #     goodcmd | badcmd can kill tpsh!
    #
    local $SIG{PIPE} = sub { warn "$lhs | ${rhs}: $!"
                                if $Options{reportpipe}
                           };
    pipe my ($lfd, $rfd) or goto fail;

    unless (my $kid = fork) {
        defined $kid or goto fail;

        # child    -> print to $rfd
        close $lfd;
        open $rcmd, '-|', $lhs;
        while (my $ln = <$rcmd>) {
            print $rfd $ln;
        }
        close $rcmd;
        exit $?;
    } elsif ($kid) {
        # parant   -> read from $lfd
        local $SIG{CHLD} = sub { waitpid($kid, 0); };
        close $rfd;
        open $lcmd, '|-', $rhs;
        while (<$lfd>) {
            print $lcmd $_;
        }
        close $lfd;
        close $lcmd;
        return 1;
    }
    return 255; # NOTREACHED

    fail: do {
        warn "can't create pipeline or fork for ${cmd}: $!";
        return 255;
    };
    notfound: do {
        warn "command not found: $cmd";
        return 255;
    };
}

sub get_history {

    # cache HISTSIZE here, incase it changes during execution
    my $histsize = $ENV{HISTSIZE};
    my @lines    = ();

    # some readline packages might not supply this function, 
    # known: Zoid, Perl, and Gnu do but Stubs doesn't. so 
    # call within an eval to be sure.
    #
    if ($ReadLineSupportsHistory) {
        @lines = eval { $Term->GetHistory() };
        if ($@) {
            warn $Term->ReadLine(), " might not support GetHistory()",
        }
    } else {
        @lines = @History;
    }

    if ( @lines > $histsize) {
        # this is far from optimized
        @lines = reverse @lines;
        $#lines -= $#lines - $histsize +1;
        @lines = reverse @lines;
    }
    return @lines;
}

sub add_history {

    unless ($ReadLineSupportsHistory) {
        push @History, @_;
    }
}

sub load_history {

    if ($ReadLineSupportsHistory) {
        eval {
            $Term->SetHistory(@_);
            $HistoryNumber += $#_;
        };
        if ($@) {
            warn $Term->ReadLine(), " might not support GetHistory()",
        }
    } else {
        push @History, @_;
        $HistoryNumber += $#_;
    }
    return 1;
}

sub save_history {
    return unless @_ and $ENV{HISTSIZE};

    my $histfile = shift;
    my $histsize = $ENV{HISTSIZE};
    my $fsize    = 0;
    my $hsize    = 0;
    my $fh       = undef;
    my @lines    = ();
    my @history  = get_history();

    open $fh, '+<', $histfile or
    open $fh, '+>', $histfile or return;

    # we must chomp off the end of line markers
    while (<$fh>) {
        chomp;
        push @lines, $_;
    }
    
    $fsize = $.;
    $hsize = $#lines + $#history +1;

    if ($hsize > $histsize) {
        # trim the file and rewrite
        for (0..$hsize-$histsize) {
            shift @lines;
        }
        seek $fh, 0, 0;
        print $fh "$_\n" foreach (@lines, @history);
    } else {
        # just append 
        print $fh "$_\n" foreach @history;
    }

    return close $fh;
}

=pod

binerr EXPR
binerr()

Display a built in error message for the last built in command. If EXPR is
given, it is used as the error message, other wise the $! special variable is
used.

=cut

sub binerr {
    print STDERR "${Last_Cmd}: ", @_ ? shift : $!;
}

sub hsplit {

    # cache changed HASHSEP to a qr for performance
    # 
    if (ref $$HashSep ne 'Regexp') {
        # trap regexp syntax errors.
        eval {
            local $SIG{__WARN__} = 'IGNORE';
            local $SIG{__DIE__}  = sub {
                my $msg = join ' ', @_;
                $msg =~ s/(marked by <-- HERE in)/$1\n/;
                die $msg, "\n";
            };
            $$HashSep = qr/$$HashSep/
        };
        if ($@) {
            warn "syntax error: $@", "\nHASHSEP cleared\n";
            $$HashSep = '';
            exit 0;
        }
    }

    return split /$$HashSep/, $_ for @_;
}

sub ifsplit {

    # if the $IFS environment varable is unset, fall back on 
    # whitespace; this is not strictly bourne compatible, but
    # is desirable none the less
    #
    my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;

    return grep !/^$/, split $ifs, join ' ', @_;
}

sub is_macro {
    my $name = shift || "";

    if (exists $Macros{$name}) {
        return defined $Macros{$name};
    }
}

sub is_builtin {
    my $cmd = shift;

    if (exists $Builtins{$cmd}) {
        return defined $Builtins{$cmd};
    }
}

sub err_handler {

    local $0 = basename $0;
    my $msg  = join( ' ', @_);

    $msg =~ s/ at (?:.*\/tpsh) line .*\n// unless $Options{debug};
    print STDERR "$0: $msg\n";
}

sub death_handler {

    local $0 = basename $0;
    my $msg  = join( ' ', @_);

    $msg =~ s/ at $0 line .*\n// unless $Options{debug};
    die "$0: ${msg}, stopping tpsh\n";
}


sub sh_eval {

    my $line   = join '', @_;
    my @data   = tpsh_lex tpsh_parse($line);

    return wantarray ? @data : join ' ', map { join ' ', @$_ } @data;
}

sub update_env {
    my ($var, $val) = @_;
    $val = sh_eval($val);

    if ($var =~ /=/) {
        # IEEE Std 1003.1-2004 forbirds = in env-var names
        return warn "Bad syntax, '$var'\n"
    }

    $ENV{$var} = "$val";
    return 0;
}


=pod

alias_bin
alias_bin EXPR
alias_bin LIST

XXX this pod needs to be updated

When given a scalar expression, it will be split on '=' and create an alias for
the left hand side, to the right hand side: this supports the Bourne Shell
style of 'alias command=value'. When given a list, it will inspect a C-Shell
style alias, in the form of 'alias command value'. If no argument list is specified, all known aliases are displayed.

=cut
sub alias_bin {
    return macros_bin unless @_;

    my @argv = @_;
    my ($lvalue, $rvalue);

    if (grep /\w=/, @argv) {
        # split Bourne style into C-Shell for easier assignment
        ($lvalue, $rvalue) = split /=/, join(' ', @argv), 2;
    } else {
        # join C-Shell style rhs into a scalar for assignment
        ($lvalue, $rvalue) = (shift @argv, join ' ', @argv);
    }

    # maybe called like alias macroname
    if (!$rvalue) {
        return 1 if (!is_macro($lvalue));
        print "'$lvalue' => '$Macros{$lvalue}'\n" if !$rvalue;
    }


    $Macros{$lvalue} = $rvalue;
    return 0;
}

sub builtin_bin {
    my $bin = shift;

    if (is_builtin $bin) {
        $Builtins{$bin}->(@_);
    } else {
        warn "not found: $bin";
        return 127;
    }
}

=pod

cd_bin
cd_bin PATH

When no argument is given, use perls 'chdir()' behavor to mimic bournes 'cd'.
Other wise attempt to change directory to PATH. If the environment variable
$CDPATH is set, search $CDPATH before giving up.

=cut

sub cd_bin {
    my $target = shift;
    my $rv     = 0;

    $target    ? ($rv = chdir $target)
               : ($rv = chdir);

    unless ($rv) {
        if (defined $ENV{CDPATH}) {
            for my $d (hsplit $ENV{CDPATH}) {
                my $dest = "${d}/$target";
                if ($target !~ /^[\/.]/) {
                    $rv = chdir $dest and last;
                }
            }
        }
    }

    warn $! unless $rv;
    $ENV{OLDPWD} = $ENV{PWD} || "";
    $ENV{PWD}    = cwd();

    return $rv ? 0 : 2; # dash returns 2 on cd /notreal
}

sub cls_bin {

    # assume unix environment
    #
    eval { 
        require Term::Cap;
        my $tcap = Tgetent Term::Cap { TERM => undef };

        # 'cl' is the control char to clear the screen
        $tcap->Trequire('cl');
        $tcap->Tputs('cl', 1, *STDOUT);
    };

    if ($@) {
        # assume Term::Cap croaked
        my $LINES = $ENV{LINES} ? $ENV{LINES} : 75;
        for (my $n=0; $n < $LINES; $n++) {
            print "\r\n";
        }
    }

    return 0;
}

sub dirs_bin {

    my $i = 0;
    for my $dir (ifsplit $ENV{DIRSTACK}) {    
        printf "%d\t%s\n", $i, $dir;
        $i += 1;
    }

    return 0;
}

sub echo_bin {

    my $i;
    my @words = @_;

    for ($i=0; $i < scalar @words; $i++) {
        print $i < $#words ? "$words[$i] " : $words[$i];
    }

    # Not sure if I this is retroactively a bug or a feature.
    return $i + print "\n";
}

# needs more testing
sub eval_bin {

    my $args = join ' ', @_;
    return eval {
        resolve_cmd scalar sh_eval $args or warn "syntax error: $args";
    };
}

sub exec_bin {
    my ($prog, @argv) = @_;

    exec { $prog } ($prog, @argv) or warn $!;
    # bet most of you forget this trick :P
    return ($! << 0);
}

sub exit_bin {
    my $ev = shift;

    defined $ev ? exit $ev : exit $? >> 8;
    return 127;
}

sub export_bin {

    return 1;
}

sub false_bin {
    return 1;
}

sub fc_bin {

    my ($e,$l,$n,$r) = (0,0,0,0);
    my @lines;
    my @argv = @_;
    my @hist = get_history();
    my $opts = {'e|editor=s'    => \$e,
                'l|list'        => \$l,
                'n'             => \$n,
                'r|reverse'     => \$r,
       };
    do_getopt(\@argv, $opts);

    my ($first, $last) = @argv;

    $first ||= ""; $last ||= "";    # darn auto-viv.

    # code refs to save on typing
    # these functions are handy, but only needed here.
    #
    my $pushln = sub {
        my ($str, $idx) = @_;
        if ($n) {
            push @lines, $str;
        } else {
            push @lines, "$idx: $str";
        }
    };
    my $println = sub {
        print $_, "\n" foreach $r ? reverse @_ : @_;
    };
    my $editln = sub {
        #
        # actually edit and re execute the command
        #

        #
        # If the OS supports /dev/fd*, use it to avoid passing the filename
        # to the users editor.
        #
        my $devfd;
        for ("/proc/$$/fd") {
        #for ("/proc/$$/fd", '/dev/fd') {  <-- doesn't work on fbsd
            if (-d $_) {
                $devfd = $_;
                last;
            }
        }

        #
        # Let the module do the right thing, for us.
        #
        File::Temp->safe_level(File::Temp::HIGH);
        my ($fh, $fn) = File::Temp::tempfile();

        #
        # write commands to temp file
        #
        map { print $fh "$_\n" } $r ? reverse @_ : @_;

        my $file = $devfd ? "${devfd}/".fileno($fh) : $fn;

        resolve_cmd $e, $file;

        #
        # execute the result as a script in current shell
        #
        source_bin($file);

        File::Temp::unlink1($fh, $fn)
            or warn "unable to clean up $fn";
    };
    my $dofc = sub {
        if ($l) {
            $println->(@_);
        } else {
            $editln->(@_);
        }
    };

    # if we are not listing, we are editing
    #
    unless ($l) {
        $n = 'so skip line numbers';
    }

    # make sure there is an editor to use
    #
    local $ENV{FCEDIT} = $ENV{FCEDIT};
    if ($e) {
        $ENV{FCEDIT} = $e;
    }
    for my $ed (qw/ FCEDIT EDITOR /) {
        if (defined $ENV{$ed}) {
            $e = $ENV{$ed};
            last;
        }
    }
    unless ($e or $l) {
        warn "no editor specified";
        return 127;
    }

    #
    # list or edit/re-exec command
    #
    unless ($first) {
        #
        # just operate on all the history (fc)
        #
        my $i = $HistoryNumber - $#hist;
        for my $ln (@hist) {
            $pushln->($ln, $i);
            $i++;
        }
        $dofc->(@lines);
    } else {
        #
        # locate the command range to use (fc first [last])
        #
        if ($first =~ /^\d/) {
            #
            # fc numerical indexes 
            #

            # XXX 
            #   user indexes are 1 based, convert to 0 based.
            #   and abort if out of range.
            $first--; $first  = int($first);
            $last--;  $last   = int($last);

            local $@;
            if ($first > $#hist) {
                $@ = "history index out of range: $first";
            }
            if ($last > $#hist) {
                $@ = "history index out of range: $last";
            }
            goto badidx if $@;

            my @buf = eval {
                $last > 0 ? @hist[$first..$last]
                          : $hist[$first];
            };
            if ($n) {
                $pushln->($_) foreach @buf;
            } else {
                # we have to manually insert the line numbers
                #
                my $k= $first + 1;
                $pushln->($_, $k), $k++ foreach @buf;
            }
            $dofc->(@lines);

          badidx:
            if ($@) {
                print STDERR "fc: ", $@;
                return 1;
            }
        } else {
            #
            # fc regexp indexes
            #

            # check for regexp syntax errors 
            # XXX we _N_E_E_D_ a global sub for this!!!
            eval {
                local $SIG{__WARN__} = 'IGNORE';
                local $SIG{__DIE__}  = sub {
                    my $msg = join ' ', @_;
                    $msg =~ s%at (?:.*tpsh) line \d*\.$%\n%;
                    die "$msg\n";
                };
                "" =~ /^$first/ or "" =~ /^$last/
            };
            if ($@) {
                print STDERR "fc: ", $@;
                return 1;
            }

            # locate the first offset by counting backwards and
            # then walk forward again if we have another regexp
            #
            my ($i,$x);
            for ($i=$#hist; $i < scalar @hist; $i--) {
                if ($hist[$i] =~ /^$first/) {
                    $x=$i+1;
                    $pushln->($hist[$i], $x);
                    last;
                }
            }
            if ($last) {
                for ($i++; $i < scalar @hist; $i++) {
                    $x=$i+1;
                    $pushln->($hist[$i], $x);
                    last if $hist[$i] =~ /^$last/;
                }
            }
            $dofc->(@lines);
        }
    }

    return 0;
}

sub function_bin {
    my ($name, $def) = (shift @_, join ' ', @_);
    unless ($name =~ s/\(\)$//) {
        warn "syntax error: did you forget the parentheses? ",
             "function $name $def";

        #return " ";
        return 2; # bash4.2.10 returns 2 for this syntax errorj  
    }
    $Macros{$name} = $def;

    return 1
}

sub hash_bin {

    if (@_) {
        if ($_[0] eq '-r') {
            %Path = ();
        } else {
            map { delete $Path{$_} or warn "command not found: $_" } @_;
        }
    } else {
        while (my ($k, $v) = each %Path) {
            print "$k=$v\n";
        }
    }

    return 0;
}

sub history_bin {

    my $c;
    my $cmd  = shift || "";
    my %cmds = ('edit'  => 'fc %s',
                'list'  => 'fc -l %s',
                'load'  => 'loadhist %s',
                'save'  => 'savehist %s',
                'help'  => 'history [edit | list | load | save | help] [args]',
       );

    if (exists $cmds{$cmd}) {
        $c = $cmds{$cmd};
        $c =~ s/%s/join ' ', @_/e;
    } else {
        $c = $cmds{list};
        $cmd ? $c =~ s/%s/$cmd/
             : $c =~ s/%s//;
    }

    return eval_bin $c;
}

sub loadhist_bin {
    return unless @_;

    my @argv  = @_;
    my @lines = ();

    for my $file (@argv) {
        open my $fh, '<', $file or warn "loadhist: $!";
        next if $!;
        while (<$fh>) {
            chomp;
            push @lines, $_;
        }
    }
    return load_history @lines;
}

sub macro_bin {
    return macros_bin unless @_;

    # name( ... ) == good 
    my @line = @_;

    # get macro name and strip the parens
    #
    my $name = shift @line;
    # macro name(foo == bad
    if ($name =~ /\w*\([\w\(\)\{\}]/) {
       warn "syntax error: no space after opening parentheses ",
            "macro ".join ' ', @_;
        return 2;
    }
    $name =~ s/\(([^\s]*)$//g;
    #
    # macro name( foo) == also bad; or handle name()
    # if the above test failed for some fault of ours
    #
    my $endmk = pop @line || '';
    if ($endmk ne ')') {
        warn "syntax error: no space before closing parentheses ",
             "macro ".join ' ', @_;
        return 2;
    }

    #$Macros{$name} = '(' . join(' ', @line) . ')';
    $Macros{$name} = join(' ', @line);
    return 0;
}

sub macros_bin {
    $Dumper->dumpValue(\%Macros);
    return 0;
}

sub popd_bin {

    my @ds  = ifsplit $ENV{DIRSTACK};
    my $dir = shift @ds;

    $ENV{DIRSTACK} = join(' ', @ds);

    my $cd = cd_bin(expand_tilde $ds[0]);
    return $cd == 0 ? dirs_bin() : $cd;
}

sub pushd_bin {
    my $dir = shift || $ENV{PWD};
    my $ds  = $ENV{DIRSTACK};

    $ENV{DIRSTACK} = "$dir $ds";

    my $cd = cd_bin(expand_tilde $dir);
    return $cd == 0 ? dirs_bin() : $cd;
}

sub pwd_bin {
    my $arg = shift || '-L';
    goto bad if @_;

    if ($arg eq '-P') {
        print Cwd::realpath($ENV{PWD}), "\n";
    } elsif ($arg eq '-L') {
        print Cwd::getcwd(), "\n";
    } else {
      bad:
        warn "to many arguments";
        return 1;
    }

    return 0;
}

sub read_bin {

    my ($prmpt, $time);
    my $line = "";
    my @argv = @_;
    my $opts = { 'p=s' => \$prmpt,
                 't=s' => \$time,
                 'e'   => sub { "no-op" },
       };

    do_getopt(\@argv, $opts);
    unless (@argv) {
        warn "I can't read into thin air!";
        return 127;
    }

    if ($prmpt and -t *STDIN) {
        print $prmpt;
    }

    eval {
        # remove custom die for ease of error check/report
        local %SIG;
        $SIG{__DIE__} = sub { die @_ };
        $SIG{ALRM}    = sub { die "timed-out\n" };
        if ($time) {
            # an s, m, or h suffix causes sleep for sec, min, or hour
            #
            if ($time =~ /^(\d*)([smh])/) {
                if ($2 eq 's') {
                    $time = $1;
                } elsif ($2 eq 'm') {
                    $time = $1 * 60;
                } elsif ($2 eq 'h') {
                    $time = $1 * 3600;
                } else {
                    warn "internal error on ", __LINE__;
                    # NOTREACHED
                }
            }
            alarm $time;
        }
        chomp($line = <STDIN>);
        alarm 0 if $time;
    };
    if ($@) {
        # on time out, init the vars to empty strings
        @ENV{@argv} = ('') x scalar @argv;

        unless($@ eq "timed-out\n") {
            # if we hit here and didn't time out, something errored.
            warn $@;
            return 1;
        }
        return 0;
    } else {
        # set each var to the words
        #
        # XXX because ifsplit has no notion of a &split 'LIMIT'
        #     if we used ifsplit here instead of a manual split,
        #       read x y
        #       foo bar ham
        #     would set $y to 'bar' instead of 'bar ham'
        #
        my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;
        @ENV{@argv} = grep !/^$/, split $ifs, $line, scalar(@argv);
        return 0;
    }
}

sub rehash_bin {
    rehash;
    return 0;
}

sub savehist_bin {

    my $histfile = shift || $ENV{HISTFILE} || "";

    return save_history $histfile;
}

sub set_bin {
    my @argv = @_;
    if (@argv) {
        do_getopt(\@argv, $Setopts);
    } else {
        # pretty print everything like sh
        foreach my $var (sort keys %ENV) {
            my $val = $ENV{$var};
            # shut up uninitialized warnings if VAR=
            #
            $val = "" unless defined $val;

            if ($val =~ /\s/) {
                $val = "'$val'";
            }
            print $var, "=", $val, "\n";
        }
        return 0;
    }
}

sub setenv_bin {
    my ($var, $val) = @_;

    return update_env($var, $val);
}

sub setvar_bin {

    return 1;
}

# this builtin doesn't follow the usual exit status convention yet and might never.
sub sleep_bin {

    my $secs = shift;

    # an s, m, or h suffix causes sleep for sec, min, or hour
    #
    if ($secs =~ /^(\d*)([smh]?)/) {
        if ($2 eq 's') {
            $secs = $1;
        } elsif ($2 eq 'm') {
            $secs = $1 * 60;
        } elsif ($2 eq 'h') {
            $secs = $1 * 3600;
        } else {
            # NOTREACHED
            unless (defined $2) {
                warn "internal error on line ", __LINE__;
            }
        }

        return sleep $secs;
    } else {
        warn "usage: sleep timespec";
        return 0;
    }
}

sub source_bin {

    my @args = @_;
    eval {
        local $SIG{__DIE__} = sub { die @_ };
        for my $file (@args) {
            open my $fh, '<', $file     or die "${file}: $!\n";
            while (defined(my $ln = <$fh>)) {
                foreach (sh_eval $ln) {
                    resolve_cmd @$_ if defined @$_;
                }
            }
        }
    };

    return warn $@ if $@;
    return 0;
}

sub test_bin {

    return 1;
}

sub times_bin {

    return 1;
}

sub trap_bin {

    return 1;
}

sub true_bin {
    return 0;
}

sub type_bin {
    my $rv = 0;

    for (@_) {
        # check macros, builtins, path, and current directory.
        #
        print "$_ is a macro for $Macros{$_}\n"   
                                    and next          if is_macro $_;
        print "$_ is a shell builtin\n" 
                                    and next          if is_builtin $_;
        if (my $p = search_path $_) {
            print "$_ is $p\n";
            next;
        }
        #
        # this is a custom exstension
        #
        print "$_ may be $ENV{PWD}/$_\n"            
                                    and next          if -x "./$_";

        print "$_ not found\n";
        # a command was not found, adjust exit status to reflect this but continue.
        $rv = 127;
    }
    return $rv;
}

sub unalias_bin {

    delete @Macros{@_};
    return 0;
}

sub unset_bin {

    return 0;
}

sub which_bin {

    # XXX all these $flag eq ... deserve an internal coderef
    my $flag  = " ";
    my $found = 0;
    my @argv  = @_;
    my @progs = ();
    my $opts  = { 'a|all'      => sub { $flag = '-a' },
                  's|sillent'  => sub { $flag = '-s' },
                  '<>'         => sub { push @progs, shift },
       };
    do_getopt(\@argv, $opts);
    #@progs = @argv;

    for (@progs) {
        # first check if built in or macro
        if (is_builtin $_) {
            print "${_}: shell built-in command\n" unless $flag eq '-s';
            $found++;
            next unless $flag eq '-a';
        }
        if (is_macro $_) {
            print "${_}: macro for $Macros{$_}\n" unless $flag eq '-s';
            $found++;
            next unless $flag eq '-a';
        }
        for my $p (hsplit $ENV{PATH}) {
            my $path = "${p}/${_}";
            if (-x $path) {
                print "$path\n" unless $flag eq '-s';
                $found++;
                last unless $flag eq '-a' or $flag eq '-s';
            }
        }
        if ($flag ne '-s') {
            print "${_}: not found\n" unless $found;
        }
    }

    if ($found >= scalar @progs) {
        $? = 0;
        return 0;
    } else {
        $? = 1 << 8;
        return 1;
    }
}

END {
    if ($Options{autohistory}) {
        savehist_bin $ENV{HISTFILE};
    }
}

#
#----------------------------------------------------------
#                begin program execution 
#----------------------------------------------------------
unless (caller) {
    do_getopt(\@ARGV, $Setopts);
    $Options{interactive} = -t *STDIN && !@ARGV ? 1 : 0;
    $Options{stdin}       = @ARGV               ? 1 : 0;
    if ($Options{cmdstr}) {
        $Options{interactive} = 0;
    }
    init_sh();
    if ($Options{cmdstr}) {
        exit resolve_cmd scalar sh_eval $Options{cmdstr};
    }
    exit main_loop();
}
