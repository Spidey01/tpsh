#!/usr/bin/env perl
#
# Terry's Portable SHell
#
#--------------------------------------------------------------------

use warnings;
use strict;


use Cwd;
use Dumpvalue;
use File::Basename;
use File::Glob          ':glob';
use File::Spec;
use File::Temp;
use Getopt::Long;       # do NOT export GetOptionsFrom*
use Term::ReadLine;


#----------------------------------------------------------
#                Subroutine Prototypes
#----------------------------------------------------------

#
# Internal subroutines
#
sub init_sh;
sub do_getop;
sub main_loop;
sub tpsh_parse;
sub tpsh_lex;
sub resolve_cmd;
sub pexec;
sub search_path;
sub handle_prompt;
sub rehash;
sub update_env;
sub sh_eval;
sub do_completion;
sub complete_filename;
sub complete_command;
sub complete_macro;
sub complete_builtin;
sub expand_quotes;
sub expand_tilde;
sub expand_parameters;
sub expand_aliases;
sub expand_glob;
sub exec_pipe;
sub get_history;
sub add_history;
sub load_history;
sub save_history;
sub binerr;
sub hsplit;
sub ifsplit;
sub is_macro;
sub is_builtin;
sub err_handler;
sub death_handler;
#
# These subs implement built in commands
#
sub alias_bin;
sub builtin_bin;
sub cd_bin;
sub cls_bin;
sub echo_bin;
sub eval_bin;
sub exit_bin;
sub export_bin;
sub fc_bin;
sub function_bin;
sub hash_bin;
sub history_bin;
sub loadhist_bin;
sub macro_bin;
sub pwd_bin;
sub read_bin;
sub rehash_bin;
sub savehist;
sub set_bin;
sub setenv_bin;
sub setvar_bin;
sub sleep_bin;
sub source_bin;
sub test_bin;
sub times_bin;
sub trap_bin;
sub type_bin;
sub unalias_bin;
sub unset_bin;
sub which_bin;

#----------------------------------------------------------
#                Global Data Structures
#----------------------------------------------------------

#
# Represents command line flags and set -options
#
my %Options = (
    allexport       =>  0,
    autohistory     =>  0,
    notify          =>  0,
    noclobber       =>  0,
    emacs           =>  1,
    errexit         =>  0,
    noglob          =>  0,
    ignoreeof       =>  0,
    interactive     =>  0,
    monitor         =>  0,
    noexec          =>  0,
    privileged      =>  0,
    pathext         =>  1,
    reportpipe      =>  0,
    stdin           =>  0,
    vi              =>  0,
    verbose         =>  0,
    xtrace          =>  0,
    cmdstr          =>  '', # used for tpsh -c "str"; do not document as set -o
);

#
# Hash for updating %Options through Getopt::Long
#
my %Setopts = (
    'a|allexport'    =>  \$Options{allexport},
    'A|autohistory'  =>  \$Options{autohistory},
    'b|notify'       =>  \$Options{notify},
    'c=s'           =>  \$Options{cmdstr},
    'C|noclobber'    =>  \$Options{noclobber},
    'E|emacs'        =>  \$Options{emacs},
    'e|errexit'      =>  \$Options{errexit},
    'f|noglob'       =>  \$Options{noglob},
    'I|ignoreeof'    =>  \$Options{ignoreeof},
    'i|interactive'  =>  \$Options{interactive},
    'm|monitor'      =>  \$Options{monitor},
    'o=s'            =>  sub {
                             my @opts = keys %Options;
                             for my $o (split /,/, $_[1]) {
                                 grep /$o/, @opts or
                                    die("no such option: $o"), last;
                                 $Options{$o} = 1;
                             }
                         },
    'p|privileged'   =>  \$Options{privileged},
    'reportpipe'     =>  \$Options{reportpipe},
    's|stdin'        =>  \$Options{stdin},
    'V|vi'           =>  \$Options{vi},
    'v|verbose'      =>  \$Options{verbose},
    'x|xtrace'       =>  \$Options{xtrace},
    #---
    #'h'              =>   \&pod2usage(-verbose => 0, -exitval => 1),
    #'help'           =>   \&pod2usage(-verbose => 1, -exitval => 1),
    #'m|man'          =>   \&pod2usage(-verbose => 3, -exitval => 0),
);


#
# Used whenever split /sep/, "foosepbar" is needed. I.e. $PATH, $CDPATH.
# init_sh will initialize and compile this as a regular expression appropirate
# for the users operating system, i.e. ':' or ':'.
#
# You should use hsplit(LIST) instead of directly using split 
#
my $HashSep = \$ENV{HASHSEP};

#
# Introspector / debugging aid -- will be initialized in init_sh()
#
my $Dumper = undef;

#
# Holds the last executed command, usually built in.
#
my $Last_Cmd = '';

#
# Holds the last parsed line of input
#
my @Last_Line = ();

#
# Internal history buffer, holds individual command lines sans the '\n'.
# This is used if the ReadLine module doesn't support history. You should
# never access this directly, use the main::*_history() functions here.
# note: generally this is here so things like fc still work with when
# Term::ReadLine::Stubs is the only read line module available.
#
my @History = ();

#
# In an interactive shell, this holds the number of command lines that have
# been entered by the user. If you call get_history() to get a list of lines
# within HISTSIZE, you can find your numerical indexs starting point within 
# the global history as $#get_history() - $HistoryNumber. 
#
my $HistoryNumber = 0;

#
# Set to a truth value if Term::ReadLine can automatically add history
# to its internal buffers when getting a line. Other wise, we need to
# do our own emulation.
#
our $ReadLineSupportsHistory = 0;


#
# Reference to our ReadLine interface
#
my $Term;

#
# A hash containing a cache of all known commands, in the format
# of command => /path/to/command. Only the rehash() sub should
# ever modify this cache directly!
#
my %Path = ();

#
# A hash of the users aliases in alias => expression format.
# The aliases are kept separate from %Builtins, so the user
# can _not_ clobber builtin commands; only mask them.
#
my %Macros = ();

#
# A hash of built in commands in the format of command => sub.
# Each handler should be named command_bin for consistency. For 
# security reasons, you should never modify this hash at runtime.
#
my %Builtins = ( '.'            => \&source_bin,
                 '['            => sub { warn "Not implemented\n" },
                 'alias'        => \&alias_bin,
                 'bg'           => sub { warn "Not implemented\n" },
                 'bind'         => sub { warn "Not implemented\n" },
                 'builtin'      => \&builtin_bin,
                 'cd'           => \&cd_bin,
                 'chdir'        => \&cd_bin,
                 'cls'          => \&cls_bin,
                 'command'      => sub { warn "Not implemented\n" },
                 'echo'         => \&echo_bin,
                 'eval'         => \&eval_bin,
                 'exec',        => \&exec_bin,
                 'exit'         => \&exit_bin,
                 'export'       => \&export_bin,
                 'false'        => sub { warn "Not implemented\n" },
                 'fc'           => \&fc_bin,
                 'fg'           => sub { warn "Not implemented\n" },
                 'function'     => \&function_bin,
                 'getopts'      => sub { warn "Not implemented\n" },
                 'hash'         => \&hash_bin,
                 'history'      =>\ &history_bin,
                 'jobs'         => sub { warn "Not implemented\n" },
                 'loadhist'     => \&loadhist_bin,
                 'local'        => sub { warn "Not implemented\n" },
                 'macro'        => \&macro_bin,
                 'pwd'          => \&pwd_bin,
                 'read'         => \&read_bin,
                 'readonly'     => sub { warn "Not implemented\n" },
                 'rehash'       => \&rehash_bin,
                 'return'       => sub { warn "Not implemented\n" },
                 'savehist'     => \&savehist_bin,
                 'set'          => \&set_bin,
                 'setenv'       => \&setenv_bin,
                 'setvar'       => \&setvar_bin,
                 'shift'        => sub { warn "Not implemented\n" },
                 'sleep'        => \&sleep_bin,
                 'source'       => \&source_bin,
                 'test'         => \&test_bin,
                 'times'        => \&times_bin,
                 'trap'         => \&trap_bin,
                 'true'         => sub { warn "Not implemented\n" },
                 'type'         => \&type_bin,
                 'ulimit'       => sub { warn "Not implemented\n" },
                 'umask'        => sub { warn "Not implemented\n" },
                 'unalias'      => \&unalias_bin,
                 'unset'        => \&unset_bin,
                 'wait'         => sub { warn "Not implemented\n" },
                 'which'        => \&which_bin,
);

#----------------------------------------------------------
#                Subroutine Implementations
#----------------------------------------------------------

sub init_sh {
    # handle default initializations for the environment
    # XXX this is a _huge_ ass sub

    # override warn/die behaviour with the desired output
    #
    $SIG{__WARN__} = \&err_handler;
    $SIG{__DIE__}  = \&death_handler;

    if (grep { $^O eq $_ } qw(VMS MacOS NetWare beos vos)) {
        warn "$0: Unsupported OS $^O -- YMMV\n";
    }

    # if none of the accepted UNIX / NT login names are found in the
    # users environment, treat this as a massively fatal error NOW.
    do {
        my $tried = 0;
        my @names = qw( USER LOGNAME USERNAME );
        for my $try (@names) {
            $tried++ unless defined $ENV{$try};
        }
        die "$0: Unable to find your username" if $tried == @names;
    };

    my ($isWin, $isUnix, %pw);
    if (grep { $^O eq $_ } qw(MSWin32 os2 dos)) {
        ($isWin, $isUnix) = (1, 0);
        require Win32API::Net;
        Win32API::Net::UserGetInfo('', $ENV{USERNAME}, 3, my $href={}) || die $!;
        %pw = ( name => $href->{name},
                homedir => $href->{homeDir} || $ENV{USERPROFILE},
                uid => $href->{userId} );
        $ENV{LOGNAME} = $pw{name};
    } else {
        ($isUnix, $isWin) = (1, 0);
        require User::pwent;
        my $pw = User::pwent::getpwnam($ENV{LOGNAME})
            or die "No username specified";
        %pw = ( name => $pw->name, homedir => $pw->dir, uid => $pw->uid, );
    }


    # XXX test this on Windows
    $Dumper = new Dumpvalue;

    # These are defaults for our own internal variables
    #
    unless ($ENV{EDITOR}) {
        if ($isUnix) {
            $ENV{EDITOR} = '/bin/ed';
        } elsif ($isWin) {
            $ENV{EDITOR} = 'edit';
        }
    }
    $ENV{HISTSIZE}  ||= 512;
    $ENV{IFS}       ||= " \t\n";
    $ENV{PS1}       ||= $pw{uid} != 1 ? '$ ' : '# ';
    $ENV{PS2}       ||= '> ';
    $ENV{PS4}       ||= '+ ';
    $ENV{CDPATH}    ||= "";

    # inheritied from the system, normally...
    $ENV{OSTYPE}    ||= $^O;
    $ENV{SHELL}     ||= $0;             #  don't use $pw to get shell.
    $ENV{HOME}      ||= $pw{homedir};
    $ENV{USER}      ||= $pw{name};
    $ENV{USERNAME}  ||= $pw{name};
    if (defined $ENV{TMPDIR}) {
        $ENV{TMP}   ||= $ENV{TMPDIR};
        $ENV{TEMP}  ||= $ENV{TMPDIR};
    } else {
        $ENV{TMPDIR} ||= $ENV{TMP} || $ENV{TEMP};
        $ENV{TMP}    ||= $ENV{TMPDIR};
        $ENV{TEMP}   ||= $ENV{TMPDIR};
    }
    # some programs (e.g. nvi) will pop a cork if TMPDIR=""
    # so delete them all, unless there is a value.
    unless (defined $ENV{TMPDIR}) {
        delete @ENV{qw/TMPDIR TMP TEMP/};
    }

    # We consider LOGNAME to be the authoritve form of the users name as
    # specified in our starting environment. This should never fail, but I'm to
    # sleepy to think clearly... so figure it out later.
    #
    if ($ENV{LOGNAME} ne $pw{name}) {
        die 'The $USER, $LOGNAME, and $USERNAME variables must match!';
    }

    $ENV{MAIL}      ||= "/var/mail/${ENV{USER}}";
    #$ENV{MAILPATH}  ||= 'unused';

    # Set defaults for shell globbing behavour
    #
    $ENV{TPSH_GLOB_FLAGS} ||= 'GLOB_QUOTE | GLOB_TILDE';


    unless (defined $ENV{PATH}) {
        $ENV{PATH} = $isUnix ? "/usr/bin:/bin"
                             : "C:/Windows/system32;C:/Windows;" .
                               "C:/Windows/System32/WBem;";
    }

    if ($isUnix) {
        $$HashSep ||= qr':';
    } else {
        $$HashSep ||= qr';';
    }
    
    rehash();

    $ENV{'$'} = $$;

    # initialize the readline library
    #
    $Term = Term::ReadLine->new($ENV{SHELL});

    $ENV{TPSH_READLINE} = $Term->ReadLine();

    my $attr = $Term->Attribs();
    my $feat = $Term->Features();

    #
    # stupid side-steps for various Term::ReadLine::Packages 
    #
    # some packages (Zoid) have problems with Features, others (Perl, Gnu) have
    # issues with respecting Attribs; so just trap this in an eval.
    #
    eval {
        if ($feat->{autohistory}) {
            $ReadLineSupportsHistory = "yes";

            # XXX ignored by Stubs and Perl
            $attr->{autohistory} = 1;
        }
    };
    if ($@ and substr($ENV{TPSH_READLINE}, 16) eq 'Zoid') {
        # band-aid for Zoid
        $attr->{autohistory} = 1;
        $ReadLineSupportsHistory = "yes";
    }
    #
    # turn off stupid ornamentation
    # XXX works in Gnu, Zoid;  !Stubs, !Perl
    #
    $attr->{ornaments} = 0;

    # Setup custom completion function
    # XXX works for Zoid, Perl, and Gnu (Zoid is best)
    #
    $attr->{completion_function}   = \&do_completion;


    # change to the users home directory by default.
    # this will also take care of the OLDPWD/PWD variables.
    #
    $Builtins{chdir}->($ENV{HOME});

    if ($Options{interactive}) {
        if (exists $ENV{ENV}) {
            map { my $f = sh_eval $_;
                  source_bin $f or warn "$f: $!";
                } hsplit $ENV{ENV};
        }
    }

    if ($Options{autohistory}) {
        loadhist_bin $ENV{HISTFILE};
    }

    unless (defined $ENV{TERM}) {
        warn "UNDEFINED TERMINAL TYPE\n";
    }
}

sub do_getopt {

    my ($argv, %opthash) = @_;

    # this is a bandaid for systems with an older Getopt::Long module
    # OpenBSD 4.5 Release for example. Comparing with floats are not
    # precise, but for this it should be accurate enough.
    #
    my $ver = $Getopt::Long::VERSION_STRING ? $Getopt::Long::VERSION_STRING
                                            : "$Getopt::Long::VERSION";

	Getopt::Long::Configure('gnu_getopt', 'getopt_compat',
                            'auto_version', 'auto_help');

    if ($ver lt '2.29') {
        # We've got to draw the line somewhere 
        #
        print STDERR "Getopt::Long version $ver is just to old... bye\n";
        sleep 10; die "Please update your Getopt::Long\n";
    } elsif ($ver lt '2.36') {
        # before 2.36, Getopt::Long can only use ARGV
        # so we save / restore it before switching it with our own
        # array reference; to mimic 2.36's GetOptionsFromArray
        #
        my @oldargv = @ARGV;
        @ARGV = @$argv;
        my $ret = GetOptions(%opthash);
        @$argv = @ARGV;
        @ARGV = @oldargv;
        return $ret;
    } else {
        return Getopt::Long::GetOptionsFromArray($argv, %opthash);
    }
}

=pod

main_loop()

Program main loop

=cut
sub main_loop {
    while (defined(my $cmdln = handle_prompt())) {
        my @buf;

        #
        # parse into tokens and stream them back after processing
        #
        push @buf, tpsh_parse($cmdln);
        @buf = tpsh_lex @buf;

        map { resolve_cmd @$_ if defined @$_ } @buf;
    }
}

sub handle_prompt {
    my $ln = "";

    if ($Options{interactive} && !$Options{stdin}) {
        $ln = $Term->readline($ENV{PS1});
        if (defined $ln and $ln =~ /\S/) {
            $HistoryNumber ++;
            add_history($ln);
        }
    } else {
        $ln = <>;
    }
    if (defined $ln) {
        if ($Options{verbose}) {
            print $ln;
            $Options{interactive} ? print "\n" : 0;
        }
        if ($Options{xtrace}) {
            # temporary side-step for killin' error messages when PS4 is bad
            my $ps4 = $ENV{PS4} || '';
            print STDERR "${ps4}$ln";
            $Options{interactive} ? print "\n" : 0;
        }
    }

    return $ln;
}

sub tpsh_parse {
    # parse this into tokens
    #
    #   cmd [args]
    #   cmd [args] |, | cmd [args], ...
    #   ..., > words ...

    my $line  = shift;
    my @stack;

    foreach my $word (expand_quotes($line)) {
        my @buf = split /([^\\]+?)([;\&\|])(.*)/, $word;
        if ($#buf) {
            push @stack, grep !/^$/, @buf;
        } else {
            push @stack, $word;
        }
    }

    return @stack;
}

sub tpsh_lex {

    # XXX this is ugly but effective: most of the sub needs refactoring.

    my $strbuf;
    my @words = @_;
    my @stack;
    my @queue;

    #
    # rejoin the tokens into the commands as a stack of args
    #
    for my $s (ifsplit (@words, ';')) {
        unless ($s =~ /^[;\|]$/) {
            #
            # handle async operator
            #
            if ($s eq '&') {
                push @$strbuf, $s;
                push @stack, $strbuf;
                $strbuf = ();
            } else {
                push @$strbuf, "$s ";
            }
        } else {
            #
            # handle pipe operator
            #
            if ($s eq '|') {
                push @$strbuf, " |";
            }
            push @stack, $strbuf;
            $strbuf = ();
        }
    }


    #
    # reconsitute the argument vector from the token stream.
    # The queue will contain array refs to the argument vectors
    # ready for resolve_cmd to use.
    #
    $strbuf = "";
    for my $ref (@stack) {
        my @tokens;
        for my $tok (@$ref) {

            # XXX s/\s/the value from ifsplit/g
            if ($tok =~ m/\\\s*$/) {
                # escaped whitespace needs to be appended
                #
                $strbuf .= $tok;
            } else {
                if ($tok =~ /\s$/ and $strbuf) {
                    # left join token onto the buffer
                    # e.g. 'foo\ bar ' -> push 'foo\ bar'
                    #
                    chop $tok;
                    push @tokens, "$strbuf $tok";
                } else {
                    # buffer is full; append with current token
                    # 'foo\ bar', 'tok ' -> push 'foo\ bar', 'tok'
                    #
                    chop $tok;
                    $strbuf =~ /^$/ ? push @tokens, $tok
                                    : push @tokens, $strbuf, $tok;
                }
                $strbuf = "";
            }
        }
        push @queue, [@tokens];
    }

    # strip out the [back]quotes
    #
    @queue = map { [map { $_ =~ s/\\//g;  $_ } @$_] } @queue;
    return @queue;
}

sub resolve_cmd {

    local $!;
    my ($cmd, @buf)   = (ifsplit shift @_);
    my @argv;  push @argv, @buf, @_;
    my $cmdln = join ' ', $cmd, @argv;
    $Last_Cmd = $cmdln;

    # skip the I/O tricks when command is the macro built-in
    goto builtin if $cmd =~ /^macro/;

    # test if it's a pipe
    #
  pipe:
    if ($cmdln =~ /([^|]*) \| ([^|]*)/) {
        return exec_pipe $1, $2 || warn "bad pipe: $!\n";
    }

    # I/O redirection
    #
    # command   >    write stdout to file
    # command   >>   append stdout to file
    # command   <    read stdout from file
    #
    # Note: >> must come before > in order for append mode to work.
    #
  redirect:
    if ($cmdln =~ /([^><]*) \s* (>>|>|<) \s* (.*)/x) {
        return warn "Bad syntax: $cmdln"
            unless defined $1 and defined $2 and defined $3;
        my ($ch, $commd, $op, $file) = (undef, $1, $2, $3);

        if ($Options{noclobber}) {
            if ( $op eq '>' and -e $file) {
                warn "'$file' already exists",
                     " and `set -o noclobber` is in effect";
                return 0;
            }
        }
        open my $fp, $op, $file or return binerr "Can't open $file: $!";

        if ($op eq '<') {
            open $ch, '|-', $commd;
            while (<$fp>) {
                print $ch $_;
            }
        } else {
            open $ch, '-|', $commd;
            while (<$ch>) {
                print $fp $_;
            }
            close $ch; close $fp;
        }
        return 1;
    }


    # built in command
    #
  builtin:
    is_builtin($cmd) ?  return $Builtins{$cmd}->(@argv)
                     :  return pexec($cmd, @argv);
}

=pod 

pexec LIST

Executes it's arguments in a child process and waits.

pexec() overrides Perl's PATH look up for exec(), by using a qualified path for
the shells %Path. exec'ing stuff this way respects the users HASHSEP, and
ensures that the operation will also respect the users pathext setting.

=cut

sub pexec {

    local $!;
    my    @cmds = @_;
    my    $c    = \$cmds[0];   # save typing
    my    $pid  = fork();

    die "Unable to fork for pexec(\@): $!"
        unless defined $pid;

    if ($pid) {
        wait();
    } else {
        my $e = $$c;
        unless ($$c = search_path $$c) {
            warn "command not found: $e";
            exit 1;
        }
        exec { $cmds[0] } @cmds;
        # FIXME /file.ext not exec'able
        warn "NOT REACHED -- CHILD ON ", __FILE__, ':', __LINE__;
        exit $? >> 8;
    }
}

=pod

search_path EXPR

Attempt to find EXPR in %Path or the users PATH, and return a valid path name
for use by pexec() or comparable value. If EXPR can not be found return false.
The order of precedence is searching the %Path hash table, then the users PATH.
If the pathext option has been set, and the command has still not be found:
then repeat the search using the users PATHEXT variable.

=cut

sub search_path {

    my $cmd = $_[0];

    # this is not portable, but works most places
    if (substr($cmd, 0, 1) =~ /[.\/\\]/) {
        return $cmd;
    }

    # try to avoid unneccessary PATHEXT checks
    #
    if (exists $Path{$cmd}) {
        return $Path{$cmd};
    } else {
        for my $p (hsplit $ENV{PATH}) {
            my $fpath = File::Spec->catfile($p, $cmd);
            if (-x $fpath) {
                return $fpath;
            }
        }
    }

    if ($Options{pathext} && exists $ENV{PATHEXT}) {
        #
        # attempt a check for file extensions via PATHEXT.
        # first via cached %Path, then the users PATH.
        #
        my $pe = $ENV{PATHEXT};
        return unless defined $pe;

        for my $ext (hsplit $ENV{PATHEXT}) {
            my $p = $cmd.$ext;
            if (exists $Path{$p}) {
                return $Path{$p};
            }
        }

        for my $p (hsplit $ENV{PATH}) {
            for my $ext (hsplit $ENV{PATHEXT}) {
                my $fpath = File::Spec->catfile($p, $cmd.$ext);
                if (-x $fpath) {
                    return $fpath;
                }
            }
        }
    }

    # we didn't find anything :-(
    return;
}

sub rehash {
    for my $dir (reverse hsplit $ENV{PATH}) {
        print "hashing $dir\n" if $Options{verbose};
        opendir my $dh, $dir 
            or warn "Unable to access $dir; skipping in \$PATH\n";
        for my $prog (readdir $dh) {
            $Path{$prog} = "${dir}/${prog}";
        }
    }
}

sub do_completion {
    my ($word, $str) = @_;
    my @completions  = ();

    # rules of thumb:
    #
    # if first word, do all completions; subject to special cases.
    # if not first word, do file completion
    #

    my @argv = ifsplit $str;
    my $grep = sub { grep { $argv[0] eq $_ }  @_ };
    #
    # complete all-stuff for these commands
    #
    my @all  = ('type', 'which');
    # complete macros for these commands
    #
    my @macs = ('alias', 'unalias');
    #
    # complete built-in commands for these commands
    #
    my @cmds = ('builtin');

    # allow command completion for things like 'builtin e^I'
    # and 'alias l^I', fall though to normal rules if needed
    #
    if ($grep->(@all)) {
        push @completions, complete_command($word);
    } elsif ($grep->(@macs)) {
        return complete_macro $word;
    } elsif ($grep->(@cmds)) {
        return complete_builtin $word;
    }

    # normal completion rules
    if ($word =~ /^$argv[0]/) {
        push @completions, complete_command($word);
        push @completions, complete_filename($word);
    } else {
        push @completions, complete_filename($word);
    }

    return sort @completions;
}

sub complete_filename {
    my $word     = expand_parameters(expand_glob(shift));
    my $basename = basename($word);
    my $dirname  = dirname($word);
    my $cwd      = $ENV{PWD};
    if ($word =~ /\/$/) {
        # make sure we complete what's in the child dir
        $basename .= "/";
    }

    # this is a cheap trick but works well for now

    cd_bin $dirname
        or warn "$! maybe $dirname was removed by another process?";

    my @a = bsd_glob "${basename}*", GLOB_MARK | GLOB_QUOTE | GLOB_TILDE;

    cd_bin $cwd
        or warn "directory overflow: $!", "maybe $cwd was removed?";

    @a = map { "${dirname}/${_}" } @a;
    return @a;
}

sub complete_command {
    my $word = shift;
    grep /^${word}.*/, (keys %Macros, keys %Builtins, keys %Path);
}

sub complete_macro {
    my $word = shift;
    grep /^${word}.*/, (keys %Macros);
}

sub complete_builtin {
    my $word = shift;
    grep /^${word}.*/, (keys %Builtins);
}

sub expand_quotes {

    my $ln          = join ' ', @_;
    my @tokens      = ();   # parsed tokens to return
    # 
    # delegate the expansion to here by quote or 'def'ault result.
    #
    my %quotes  = ("'" => sub { my $data = shift;
                                push @tokens, quotemeta $data;
                   },
                   '"' => sub { my $data = shift;
                                $data    = expand_parameters($data);
                                push @tokens, quotemeta($data);
                   },
                   '`' => sub { my $data = shift;
                                open my $cmd, '-|', $data or warn $!;
                                my $buf;
                                $buf .= $_ while readline $cmd;
                                close $cmd;
                                push @tokens, $buf;
                   },
                   'def' => sub { my $data = shift; 
                                  push @tokens, ifsplit expand_parameters(
                                      scalar expand_aliases(
                                          expand_glob($data)));
                   },
       );

    # I can read this perfectly fine, maybe some can't so here's better
    # example of the expression -- Terry.
    #
    #                unqu    start quote      isqu   end quote   mayqu
    unless ($ln =~ /(.+?) (?<!\\) ([\'\"\`]) (.*?)  (?<!\\)(\2) (.*) /x) {
        #
        # just feed back the expanded fields if no quotes
        #
        $quotes{def}->($ln);
        return @tokens;
    } else {
        #
        # example 
        #
        # echo -'--hi bye--'- 2
        #    $1-$2--$3--$4-$5
        #
        # 1 and 5 are not quoted with the same quote
        # 2 and 4 are the current quotes
        # 3 is the content between them (e.g. $2$3$2)
        # the content of 5 may or may not contain external quotes.
        #
        #
        # use 'qu' as slang for 'quote[ed]' here.
        my $qu      = $2;
        my $unqu    = $1;
        my $isqu    = $3;
        my $mayqu   = $5;
        print "expand_quotes $qu: $unqu | $isqu | $mayqu\n";


        $quotes{def}->($unqu) if $unqu !~ /^\s*$/;

        exists $quotes{$qu} ?  $quotes{$qu}->($isqu)
                            :  $quotes{def}->($isqu);

        push @tokens, grep !/^\s*$/, expand_quotes $mayqu;

        return @tokens;
    }
}

# handle tilde expansions
sub expand_tilde {

    my $ln = wantarray ? join ' ', @_ : shift;

    while ($ln =~ m%~%) {
        unless ($ln =~ m%\\~%) {
            $ln =~ s%~%$ENV{HOME}%;
        }
    }
    return $ln;
}

# expand environment variables
sub expand_parameters {

    my $ln = shift;

    # XXX todo: use a global symbol table or a function to check between 
    # %ENV and %VARS or something like that
    #
    while ($ln =~ /(?<!\\)\$(\w*)/) {
        my $var = $1;
        if (exists $ENV{$var}) {
            $ln =~ s/\$$var/$ENV{$var}/;
        } else {
            $ln =~ s/\$$var//;
        }
    }

    return $ln;
}

# expand aliases
sub expand_aliases {

    my @argv = @_;
    unless (is_macro $argv[0]) {
        return wantarray ? @argv : join ' ', @argv;
    }
    my @nargv;
    my $exp;
    my %cache;

    local %ENV       = %ENV;
    @ENV{0..$#argv}  = @argv;
    $argv[0]         = $Macros{$argv[0]};
    @nargv           = (ifsplit($argv[0]),@argv[1..$#argv]);

    # try splitting the macro expansion, and resubjecting it to
    # continued macro expansions until we reach a finite expansion, 
    # or encounter an unresolvable macro (it's done or circular). 
    #
    # In the chain x -> y -> z -> x; x resolves to back to x.
    #
    # notes:
    #
    #   the %cache stores back refs, i.e. y => x, x => z, z => y
    #
    #   macros may expand to commands with spaces, so the expansions
    #   must under go the (cmd, args, ...) treatment with ifsplit.
    #
    #   Each expansion must have access to it's own local()ized set
    #   of positional parameters. XXX params not yet implemented
    #
    while (1) {
        last unless is_macro $nargv[0];

        # to save typing
        my $a    = \$nargv[0];
        my $p    = $nargv[0];

        # re-local the positional parameters
        #
        local %ENV        = %ENV;
        @ENV{0..$#nargv}  = @nargv;

        $$a     = $Macros{$$a};
        @nargv  = (ifsplit(shift @nargv), @nargv);
        $cache{(ifsplit($$a))[0]} = $p;

        # XXX remember the cache stores macro names back-ref'ed !!!
        #
        grep {
            if (exists $cache{$_} && $cache{$_} eq $nargv[0]) {
               $nargv[0] = $cache{$nargv[0]};
               last;
            }
        } keys %cache;

    }

    return wantarray ? @nargv : join ' ', @nargv;
}

# returns " " on error
#
sub expand_glob {

    return @_ if $Options{noglob};

    my $flags = eval "$ENV{TPSH_GLOB_FLAGS}";
    if ($@) {
        warn "syntax error in \$TPSH_GLOB_FLAGS: $!";
        return " ";
    }
    my $globch = qr/[\[\]\{\}?*]/;
    my @argv;

    for (ifsplit @_) {
        my @args = bsd_glob $_, $flags;
        if (!@args and /$globch/) {
                warn "no matches found: $_\n";
                return " ";
        }
        push @argv, @args ? @args : $_;
    }

    return @argv
}

sub exec_pipe {
    # e.g.   ls     |    head 
    my     ($lhs    ,   $rhs)     = @_;
    my     ($lcmd   ,   $rcmd,    $cmd);

    # sanity check the commands, delegating reporting
    # any error to our caller.
    #
    for my $side (($lhs, $rhs)) {
        my @arg = ifsplit $side; $cmd = shift @arg;
        next if -x $cmd;
        goto notfound unless defined $Path{$cmd} and -x $Path{$cmd};
    }

    # XXX we must trap SIGPIPE or things like 
    #     ls | head 1 will kill tpsh!
    #
    local $SIG{PIPE} = sub { warn "$lhs | ${rhs}: $!"
                                if $Options{reportpipe}
                           };
    pipe my ($lfd, $rfd) or goto fail;

    unless (my $kid = fork) {
        defined $kid or goto fail;

        # child    -> print to $rfd
        close $lfd;
        open $rcmd, '-|', $lhs;
        while (my $ln = <$rcmd>) {
            print $rfd $ln;
        }
        close $rcmd;
        exit $?;
    } elsif ($kid) {
        # parant   -> read from $lfd
        local $SIG{CHLD} = sub { waitpid($kid, 0); };
        close $rfd;
        open $lcmd, '|-', $rhs;
        while (<$lfd>) {
            print $lcmd $_;
        }
        close $lfd;
        close $lcmd;
        return 1;
    }
    return 255; # NOTREACHED

    fail: do {
        warn "can't create pipeline or fork for ${cmd}: $!";
        return 255;
    };
    notfound: do {
        warn "command not found: $cmd";
        return 255;
    };
}

sub get_history {

    # cache HISTSIZE here, incase it changes during execution
    my $histsize = $ENV{HISTSIZE};
    my @lines    = ();

    # some readline packages might not supply this function, 
    # known: Zoid, Perl, and Gnu do but Stubs doesn't. so 
    # call within an eval to be sure.
    #
    if ($ReadLineSupportsHistory) {
        @lines = eval { $Term->GetHistory() };
        if ($@) {
            warn $Term->ReadLine(), " might not support GetHistory()",
        }
    } else {
        @lines = @History;
    }

    if ( @lines > $histsize) {
        # this is far from optimized
        @lines = reverse @lines;
        $#lines -= $#lines - $histsize +1;
        @lines = reverse @lines;
    }
    return @lines;
}

sub add_history {

    unless ($ReadLineSupportsHistory) {
        push @History, @_;
    }
}

sub load_history {

    if ($ReadLineSupportsHistory) {
        eval {
            $Term->SetHistory(@_);
            $HistoryNumber += $#_;
        };
        if ($@) {
            warn $Term->ReadLine(), " might not support GetHistory()",
        }
    } else {
        push @History, @_;
        $HistoryNumber += $#_;
    }
    return 1;
}

sub save_history {

    my $histfile = shift;
    my $histsize = $ENV{HISTSIZE} || 0;
    my $fsize    = 0;
    my $hsize    = 0;
    my $fh       = undef;
    my @lines    = ();
    my @history  = get_history();

    open $fh, '+<', $histfile or
    open $fh, '+>', $histfile or return;

    # we must chomp off the end of line markers
    while (<$fh>) {
        chomp;
        push @lines, $_;
    }
    
    $fsize = $.;
    $hsize = $#lines + $#history +1;

    if ($hsize > $histsize) {
        # trim the file and rewrite
        for (0..$hsize-$histsize) {
            shift @lines;
        }
        seek $fh, 0, 0;
        map { print $fh "$_\n" } (@lines, @history);
    } else {
        # just append 
        map { print $fh "$_\n" } @history;
    }

    return close $fh;
}

=pod

binerr EXPR
binerr()

Display a built in error message for the last built in command. If EXPR is
given, it is used as the error message, other wise the $! special variable is
used.

=cut

sub binerr {
    print STDERR "${Last_Cmd}: ", @_ ? shift : $!;
}

sub hsplit {

    # cache changed HASHSEP to a qr for performance
    # 
    if (ref $$HashSep ne 'Regexp') {
        # trap regexp syntax errors.
        eval {
            local $SIG{__WARN__} = 'IGNORE';
            local $SIG{__DIE__}  = sub {
                my $msg = join ' ', @_;
                $msg =~ s/(marked by <-- HERE in)/$1\n/;
                die $msg, "\n";
            };
            $$HashSep = qr/$$HashSep/
        };
        if ($@) {
            warn "syntax error: $@", "\nHASHSEP cleared\n";
            $$HashSep = '';
            exit 0;
        }
    }

    return split /$$HashSep/, $_ for @_;
}

sub ifsplit {

    # if the $IFS environment varable is unset, fall back on 
    # whitespace; this is not strictly bourne compatible, but
    # is desirable none the less
    #
    my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;

    return grep !/^$/, split $ifs, join ' ', @_;
}

sub is_macro {
    my $name = shift || "";

    if (exists $Macros{$name}) {
        return defined $Macros{$name};
    }
}

sub is_builtin {
    my $cmd = shift;

    if (exists $Builtins{$cmd}) {
        return defined $Builtins{$cmd};
    }
}

sub err_handler {

    my $msg = join( ' ', @_);

    $msg =~ s/ at $0 line .*\n//;
    print STDERR "$0: $msg\n";
}

sub death_handler {

    my $msg = join( ' ', @_);

    $msg =~ s/ at $0 line .*\n//;
    die "$0: ${msg}, stopping tpsh\n";
}


sub sh_eval {
    # XXX none of this understands the shells quoting rules

    my $ln   = join ' ', expand_glob(@_);
    my @argv = ifsplit $ln;

    $ln = expand_aliases(@argv);
    $ln = expand_parameters($ln);
    #$ln = expand_tilde($ln);

    return wantarray ? ifsplit $ln  : $ln;
}

sub update_env {
    my ($var, $val) = @_;
    $val = sh_eval($val);

    return warn "$0: Bad syntax, '$var'\n"
        if $var =~ /=/; # IEEE Std 1003.1-2004 forbirds = in env-var names

    $ENV{$var} = "$val";
}


=pod

alias_bin
alias_bin EXPR
alias_bin LIST

When given a scalar expression, it will be split on '=' and create an alias for
the left hand side, to the right hand side: this supports the Bourne Shell
style of 'alias command=value'. When given a list, it will inspect a C-Shell
style alias, in the form of 'alias command value'. If no argument list is specified, all known aliases are displayed.

=cut
sub alias_bin {
    unless (@_) {
        $Dumper->dumpValue(\%Macros);
        return 1;
    }
    my @argv = @_;
    my ($lvalue, $rvalue);

    if (grep /=/, @argv) {
        # split Bourne style into C-Shell for easier assignment
        ($lvalue, $rvalue) = split /=/, join(' ', @argv), 2;
    } else {
        # join C-Shell style rhs into a scalar for assignment
        ($lvalue, $rvalue) = (shift @argv, join ' ', @argv);
    }
    unless ($rvalue) {
        if (is_macro $lvalue) {
            print "'$lvalue' => '$Macros{$lvalue}'\n";
        }
        return 1
    }

    $Macros{$lvalue} = $rvalue;
    return 1;
}

sub builtin_bin {
    my $bin = shift;

    if (is_builtin $bin) {
        $Builtins{$bin}->(@_);
    } else {
        warn "not found: $bin";
    }
}

=pod

cd_bin
cd_bin PATH

When no argument is given, use perls 'chdir()' behavor to mimic bournes 'cd'.
Other wise attempt to change directory to PATH. If the environment variable
$CDPATH is set, search $CDPATH before giving up.

=cut

sub cd_bin {
    my $target = shift;
    my $rv     = 0;

    $target    ? ($rv = chdir $target)
               : ($rv = chdir);

    unless ($rv) {
        if (defined $ENV{CDPATH}) {
            for my $d (hsplit $ENV{CDPATH}) {
                my $dest = "${d}/$target";
                if ($target !~ /^[\/.]/) {
                    $rv = chdir $dest and last;
                }
            }
        }
    }

    warn $! unless $rv;
    $ENV{OLDPWD} = $ENV{PWD} || "";
    $ENV{PWD}    = cwd();
    return $rv;
}

sub cls_bin {

    # assume unix environment
    #
    eval { 
        require Term::Cap;
        my $tcap = Tgetent Term::Cap { TERM => undef };

        # 'cl' is the control char to clear the screen
        $tcap->Trequire('cl');
        $tcap->Tputs('cl', 1, *STDOUT);
    };

    if ($@) {
        # assume Term::Cap croaked
        my $LINES = $ENV{LINES} ? $ENV{LINES} : 50;
        for (my $n=0; $n < $LINES; $n++) {
            print "\r\n";
        }
    }
    return 1;
}

sub echo_bin {

    print map { "$_ " } @_;
    print "\n";
}

sub eval_bin {

    my $args = join ' ', @_;
    return eval {
        tpsh_parse $args or warn "syntax error: $args";
    };
}

sub exec_bin {
    my ($prog, @argv) = @_;

    exec { $prog } ($prog, @argv) or warn $!;
}

sub exit_bin {
    my $ev = shift;

    defined $ev ? exit $ev : exit $? >> 8;
}

sub export_bin {

}

sub fc_bin {

    my ($e,$l,$n,$r) = (0,0,0,0);
    my @lines;
    my @argv = @_;
    my @hist = get_history();
    my %opts = ('e|editor=s'    => \$e,
                'l|list'        => \$l,
                'n'             => \$n,
                'r|reverse'     => \$r,
       );
    do_getopt(\@argv, %opts);

    my ($first, $last) = @argv;

    $first ||= ""; $last ||= "";    # darn auto-viv.

    # code refs to save on typing
    # these functions are handy, but only needed here.
    #
    my $pushln = sub {
        my ($str, $idx) = @_;
        if ($n) {
            push @lines, $str;
        } else {
            push @lines, "$idx: $str";
        }
    };
    my $println = sub {
        if ($r) {
            map { print "$_\n" } reverse @_;
        } else {
            map { print "$_\n" } @_;
        }
    };
    my $editln = sub {
        #
        # actually edit and re execute the command
        #

        #
        # If the OS supports /dev/fd*, use it to avoid passing the filename
        # to the users editor.
        #
        my $devfd;
        for ("/proc/$$/fd") {
        #for ("/proc/$$/fd", '/dev/fd') {  <-- doesn't work on fbsd
            if (-d $_) {
                $devfd = $_;
                last;
            }
        }

        #
        # Let the module do the right thing, for us.
        #
        File::Temp->safe_level(File::Temp::HIGH);
        my ($fh, $fn) = File::Temp::tempfile();

        #
        # write commands to temp file
        #
        map { print $fh "$_\n" } $r ? reverse @_ : @_;

        my $file = $devfd ? "${devfd}/".fileno($fh) : $fn;

        resolve_cmd $e, $file;

        #
        # execute the result as a script in current shell
        #
        source_bin($file);

        File::Temp::unlink1($fh, $fn)
            or warn "unable to clean up $fn";
    };
    my $dofc = sub {
        if ($l) {
            $println->(@_);
        } else {
            $editln->(@_);
        }
    };

    # if we are not listing, we are editing
    #
    unless ($l) {
        $n = 'so skip line numbers';
    }

    # make sure there is an editor to use
    #
    local $ENV{FCEDIT} = $ENV{FCEDIT};
    if ($e) {
        $ENV{FCEDIT} = $e;
    }
    for my $ed (qw/ FCEDIT EDITOR /) {
        if (defined $ENV{$ed}) {
            $e = $ENV{$ed};
            last;
        }
    }
    unless ($e or $l) {
        warn "no editor specified";
        return 0;
    }

    #
    # list or edit/re-exec command
    #
    unless ($first) {
        #
        # just operate on all the history (fc)
        #
        my $i = $HistoryNumber - $#hist;
        for my $ln (@hist) {
            $pushln->($ln, $i);
            $i++;
        }
        $dofc->(@lines);
    } else {
        #
        # locate the command range to use (fc first [last])
        #
        if ($first =~ /^\d/) {
            #
            # fc numerical indexes 
            #

            # XXX 
            #   user indexes are 1 based, convert to 0 based.
            #   and abort if out of range.
            $first--; $first  = int($first);
            $last--;  $last   = int($last);

            local $@;
            if ($first > $#hist) {
                $@ = "history index out of range: $first";
            }
            if ($last > $#hist) {
                $@ = "history index out of range: $last";
            }
            goto badidx if $@;

            my @buf = eval {
                $last > 0 ? @hist[$first..$last]
                          : $hist[$first];
            };
            if ($n) {
                map { $pushln->($_) } @buf;
            } else {
                # we have to manually insert the line numbers
                #
                my $k= $first + 1;
                map { $pushln->($_, $k); $k++ } @buf;
            }
            $dofc->(@lines);

          badidx:
            if ($@) {
                print STDERR "fc: ", $@;
                return 0;
            }
        } else {
            #
            # fc regexp indexes
            #

            # check for regexp syntax errors 
            # XXX we _N_E_E_D_ a global sub for this!!!
            eval {
                local $SIG{__WARN__} = 'IGNORE';
                local $SIG{__DIE__}  = sub {
                    my $msg = join ' ', @_;
                    $msg =~ s%at (?:.*tpsh) line \d*\.$%\n%;
                    die "$msg\n";
                };
                "" =~ /^$first/ or "" =~ /^$last/
            };
            if ($@) {
                print STDERR "fc: ", $@;
                return 0;
            }

            # locate the first offset by counting backwards and
            # then walk forward again if we have another regexp
            #
            my ($i,$x);
            for ($i=$#hist; $i < scalar @hist; $i--) {
                if ($hist[$i] =~ /^$first/) {
                    $x=$i+1;
                    $pushln->($hist[$i], $x);
                    last;
                }
            }
            if ($last) {
                for ($i++; $i < scalar @hist; $i++) {
                    $x=$i+1;
                    $pushln->($hist[$i], $x);
                    last if $hist[$i] =~ /^$last/;
                }
            }
            $dofc->(@lines);
        }
    }

    return 1;
}

sub function_bin {
    my ($name, $def) = (shift @_, join ' ', @_);
    unless ($name =~ s/\(\)$//) {
        warn "syntax error: did you forget the parentheses? ",
             "function $name $def";

        return " ";
    }
    $Macros{$name} = $def;
}

sub hash_bin {

    if (@_) {
        if ($_[0] eq '-r') {
            %Path = ();
        } else {
            map { delete $Path{$_} or warn "command not found: $_" } @_;
        }
    } else {
        while (my ($k, $v) = each %Path) {
            print "$k=$v\n";
        }
    }

    return 1;
}

sub history_bin {

    my $c;
    my $cmd  = shift || "";
    my %cmds = ('edit'  => 'fc %s',
                'list'  => 'fc -l %s',
                'load'  => 'loadhist %s',
                'save'  => 'savehist %s',
                'help'  => 'history [edit | list | load | save | help] [args]',
       );

    if (exists $cmds{$cmd}) {
        $c = $cmds{$cmd};
        $c =~ s/%s/join ' ', @_/e;
    } else {
        $c = $cmds{list};
        $cmd ? $c =~ s/%s/$cmd/
             : $c =~ s/%s//;
    }

    return eval_bin $c;
}

sub loadhist_bin {

    my @argv  = @_;
    my @lines = ();

    for my $file (@argv) {
        open my $fh, '<', $file or warn "loadhist: $!";
        next if $!;
        while (<$fh>) {
            chomp;
            push @lines, $_;
        }
    }
    return load_history @lines;
}

sub macro_bin {

    # name( ... ) == good 
    my @line = @_;

    # get macro name and strip the parens
    #
    my $name = shift @line;
    # macro name(foo == bad
    if ($name =~ /\w*\([\w\(\)\{\}]/) {
       warn "syntax error: no space after opening parentheses ",
            "macro ".join ' ', @_;
        return " ";
    }
    $name =~ s/\(([^\s]*)$//g;
    #
    # macro name( foo) == also bad; or handle name()
    # if the above test failed for some fault of ours
    #
    my $endmk = pop @line || '';
    if ($endmk ne ')') {
        warn "syntax error: no space before closing parentheses ",
             "macro ".join ' ', @_;
        return " ";
    }

    #$Macros{$name} = '(' . join(' ', @line) . ')';
    $Macros{$name} = join(' ', @line);
}

sub pwd_bin {
    my $arg = shift || '-L';
    goto bad if @_;

    if ($arg eq '-P') {
        return print Cwd::realpath($ENV{PWD}), "\n";
    } elsif ($arg eq '-L') {
        return print Cwd::getcwd(), "\n";
    } else {
      bad:
        return warn "to many arguments";
    }

}

sub read_bin {

    my ($prmpt, $time);
    my $line = "";
    my @argv = @_;
    my %opts = ( 'p=s' => \$prmpt,
                 't=s' => \$time,
                 'e'   => sub { "no-op" },
               );

    do_getopt(\@argv, %opts);
    unless (@argv) {
        warn "I can't read into thin air!";
        return 0;
    }

    if ($prmpt and -t *STDIN) {
        print $prmpt;
    }

    eval {
        # remove custom die for ease of error check/report
        local %SIG;
        $SIG{__DIE__} = sub { die @_ };
        $SIG{ALRM}    = sub { die "timed-out\n" };
        if ($time) {
            # an s, m, or h suffix causes sleep for sec, min, or hour
            #
            if ($time =~ /^(\d*)([smh])/) {
                if ($2 eq 's') {
                    $time = $1;
                } elsif ($2 eq 'm') {
                    $time = $1 * 60;
                } elsif ($2 eq 'h') {
                    $time = $1 * 3600;
                } else {
                    warn "internal error on ", __LINE__;
                    # NOTREACHED
                }
            }
            alarm $time;
        }
        chomp($line = <STDIN>);
        alarm 0 if $time;
    };
    if ($@) {
        warn $@ unless $@ eq "timed-out\n";
        # on time out, init the vars to empty strings
        @ENV{@argv} = ('') x scalar @argv;
        return 0;
    } else {
        # set each var to the words
        #
        # XXX because ifsplit has no notion of a &split 'LIMIT'
        #     if we used ifsplit here instead of a manual split,
        #       read x y
        #       foo bar ham
        #     would set $y to 'bar' instead of 'bar ham'
        #
        my $ifs = defined $ENV{IFS} ? qr/[$ENV{IFS}]/ : qr/\s/;
        @ENV{@argv} = grep !/^$/, split $ifs, $line, scalar(@argv);
        return 1;
    }
}

sub rehash_bin {
    rehash;
    return 1;
}

sub savehist_bin {

    my $histfile = shift || $ENV{HISTFILE} || "";

    return save_history $histfile;
}

sub set_bin {
    my @argv = @_;
    if (@argv) {
        do_getopt(\@argv, %Setopts);
    } else {
        # pretty print everything like sh
        while (my ($var, $val) = each %ENV) {
            # shut up uninitialized warnings if VAR=
            #
            $val = "" unless defined $val;

            if ($val =~ /\s/) {
                $val = "'$val'";
            }
            print $var, "=", $val, "\n";
        }
        return 1;
    }
}

sub setenv_bin {
    my ($var, $val) = @_;

    update_env($var, $val);
}

sub setvar_bin {

}

sub sleep_bin {

    my $secs = shift;

    # an s, m, or h suffix causes sleep for sec, min, or hour
    #
    if ($secs =~ /^(\d*)([smh]?)/) {
        if ($2 eq 's') {
            $secs = $1;
        } elsif ($2 eq 'm') {
            $secs = $1 * 60;
        } elsif ($2 eq 'h') {
            $secs = $1 * 3600;
        } else {
            # NOTREACHED
            unless (defined $2) {
                warn "internal error on line ", __LINE__;
            }
        }

        return sleep $secs;
    } else {
        warn "usage: sleep timespec";
        return 0;
    }
}

sub source_bin {

    my @args = @_;
    eval {
        local $SIG{__DIE__} = sub { die @_ };
        for my $file (@args) {
            open my $fh, '<', $file     or die "${file}: $!\n";
            while (defined(my $ln = <$fh>)) {
                tpsh_parse $ln            or warn "bad lex: $ln";
            }
        }
    };
    warn $@ if $@;

    return 1;
}

sub test_bin {

}

sub times_bin {

}

sub trap_bin {

}

sub type_bin {

    for (@_) {
        # check macros, builtins, path, and current directory.
        #
        print "$_ is a macro for $Macros{$_}\n"   
                                    and next          if is_macro $_;
        print "$_ is a shell builtin\n" 
                                    and next          if is_builtin $_;
        if (my $p = search_path $_) {
            print "$_ is $p\n";
            next;
        }
        #
        # this is a custom exstension
        #
        print "$_ may be $ENV{PWD}/$_\n"            
                                    and next          if -x "./$_";

        print "$_ not found\n";
    }
    return 1;
}

sub unalias_bin {

    delete @Macros{@_};
}

sub unset_bin {

}

sub which_bin {

    # XXX all these $flag eq ... deserve an internal coderef
    my $flag  = " ";
    my $found = 0;
    my @argv  = @_;
    my @progs = ();
    my %opts  = ( 'a|all'      => sub { $flag = '-a' },
                  's|sillent'  => sub { $flag = '-s' },
                  '<>'         => sub { push @progs, shift },
       );
    do_getopt(\@argv, %opts);
    #@progs = @argv;

    for (@progs) {
        # first check if built in or macro
        if (is_builtin $_) {
            print "${_}: shell built-in command\n" unless $flag eq '-s';
            $found++;
            next unless $flag eq '-a';
        }
        if (is_macro $_) {
            print "${_}: macro for $Macros{$_}\n" unless $flag eq '-s';
            $found++;
            next unless $flag eq '-a';
        }
        for my $p (hsplit $ENV{PATH}) {
            my $path = "${p}/${_}";
            if (-x $path) {
                print "$path\n" unless $flag eq '-s';
                $found++;
                last unless $flag eq '-a' or $flag eq '-s';
            }
        }
        if ($flag ne '-s') {
            print "${_}: not found\n" unless $found;
        }
    }

    if ($found >= scalar @progs) {
        $? = 0;
        return 1;
    } else {
        $? = 1 << 8;
        return 0;
    }
}

END {
    if ($Options{autohistory}) {
        savehist_bin $ENV{HISTFILE};
    }
}

#
#----------------------------------------------------------
#                begin program execution 
#----------------------------------------------------------
if (__PACKAGE__ eq 'main') {
    do_getopt(\@ARGV, %Setopts);
    $Options{interactive} = -t *STDIN && !@ARGV ? 1 : 0;
    $Options{stdin}       = @ARGV               ? 1 : 0;
    if ($Options{cmdstr}) {
        $Options{interactive} = 0;
    }
    init_sh();
    if ($Options{cmdstr}) {
        exit tpsh_parse $Options{cmdstr};
    }
    exit main_loop();
}
